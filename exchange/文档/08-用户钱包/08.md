# 用户钱包

## 1. 用户钱包信息

### 1.1 接口说明

请求uri： `/uc/asset/wallet`

参数：

| 参数         | 类型   | 描述   |
| ------------ | ------ | ------ |
| x-auth-token | string | header |

返回值：

~~~json
{
    "code":0,
    "message":"success",
    "data":[
        {
            "id":20,
            "address":"mqXLUqxec4Z2G4sP1kG621SfHgu8cnK3zu",
            "balance":980,
            "frozenBalance":20,
            "releaseBalance":0,
            "isLock":0,
            "memberId":3,
            "version":0,
            "coin":{
                "id":1,
                "name":"Bitcoin",
                "canAutoWithdraw":0,
                "canRecharge":1,
                "canTransfer":1,
                "canWithdraw":1,
                "cnyRate":195499.4044,
                "enableRpc":0,
                "isPlatformCoin":0,
                "maxTxFee":0.0002,
                "maxWithdrawAmount":5,
                "minTxFee":0.0002,
                "minWithdrawAmount":0.001,
                "nameCn":"比特币",
                "sort":1,
                "status":0,
                "unit":"BTC",
                "usdRate":28399.1,
                "withdrawThreshold":0.1,
                "hasLegal":0,
                "coldWalletAddress":"",
                "minerFee":0,
                "withdrawScale":4,
                "accountType":0,
                "depositAddress":"",
                "infolink":"",
                "information":"",
                "minRechargeAmount":0
            },
            "toReleased":0
        },
        {
            "id":19,
            "address":"",
            "balance":8629059.6,
            "frozenBalance":1149342.4,
            "releaseBalance":0,
            "isLock":0,
            "memberId":3,
            "version":0,
            "coin":{
                "id":8,
                "name":"USDT",
                "canAutoWithdraw":1,
                "canRecharge":1,
                "canTransfer":1,
                "canWithdraw":1,
                "cnyRate":6.884,
                "enableRpc":1,
                "isPlatformCoin":0,
                "maxTxFee":0.0002,
                "maxWithdrawAmount":5,
                "minTxFee":0.0002,
                "minWithdrawAmount":0.001,
                "nameCn":"泰达币T",
                "sort":1,
                "status":0,
                "unit":"USDT",
                "usdRate":1,
                "withdrawThreshold":0.1,
                "hasLegal":0,
                "coldWalletAddress":"",
                "minerFee":0,
                "withdrawScale":4,
                "accountType":0,
                "depositAddress":"",
                "infolink":"",
                "information":"",
                "minRechargeAmount":0
            },
            "toReleased":0
        }
    ]
}
~~~

### 1.2 实现

#### 1.2.1 api

~~~go
assetGroup.Post("/uc/asset/wallet", asset.FindWallet)
~~~

~~~go

func (h *AssetHandler) FindWallet(w http.ResponseWriter, r *http.Request) {
	var req = types.AssetReq{}
	ip := tools.GetRemoteClientIp(r)
	req.Ip = ip
	l := logic.NewAssetLogic(r.Context(), h.svcCtx)
	resp, err := l.FindWallet(&req)
	result := common.NewResult().Deal(resp, err)
	httpx.OkJsonCtx(r.Context(), w, result)
}
~~~

~~~go

func (l *Asset) FindWallet(req *types.AssetReq) ([]*types.MemberWallet, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	value := l.ctx.Value("userId").(int64)
	memberWallets, err := l.svcCtx.UAssetRpc.FindWallet(ctx, &asset.AssetReq{
		UserId: value,
	})
	if err != nil {
		return nil, err
	}
	var resp []*types.MemberWallet
	if err := copier.Copy(&resp, memberWallets.List); err != nil {
		return nil, err
	}
	return resp, nil
}
~~~

#### 1.2.2 rpc

~~~protobuf
message MemberWalletList {
  repeated MemberWallet list = 1;
}
service Asset {
  rpc findWalletBySymbol(AssetReq) returns(MemberWallet);
  rpc findWallet(AssetReq) returns(MemberWalletList);
}
~~~

~~~go

func (l *AssetLogic) FindWallet(req *asset.AssetReq) (*asset.MemberWalletList, error) {
	mws, err := l.memberWalletDomain.FindWalletByMemId(l.ctx, req.UserId)
	if err != nil {
		return nil, err
	}
	var list []*model.MemberWalletCoin
	for _, v := range mws {
		coinInfo, err := l.svcCtx.MarketRpc.FindCoinInfo(l.ctx, &market.MarketReq{
			Unit: v.CoinName,
		})
		if err != nil {
			return nil, err
		}
		list = append(list, l.memberWalletDomain.Copy(v, coinInfo))
	}
	var mwList []*asset.MemberWallet
	copier.Copy(&mwList, list)
	return &asset.MemberWalletList{
		List: mwList,
	}, nil
}

~~~

~~~go
func (d *MemberWalletDomain) FindWalletByMemId(ctx context.Context, userId int64) ([]*model.MemberWallet, error) {
	memberWallets, err := d.memberWalletRepo.FindByMemId(ctx, userId)
	return memberWallets, err
}
~~~

~~~go
type MemberWalletRepo interface {
	Save(ctx context.Context, mw *model.MemberWallet) error
	FindByIdAndCoinName(ctx context.Context, memId int64, coinName string) (mw *model.MemberWallet, err error)
	UpdateFreeze(ctx context.Context, conn msdb.DbConn, memId int64, money float64, symbol string) error
	UpdateBalance(ctx context.Context, wallet *model.MemberWallet) error
	FindByMemId(ctx context.Context, memId int64) ([]*model.MemberWallet, error)
}

~~~

~~~go
func (m *MemberWalletDao) FindByMemId(ctx context.Context, memId int64) (list []*model.MemberWallet, err error) {
	session := m.conn.Session(ctx)
	err = session.Model(&model.MemberWallet{}).Where("member_id=?", memId).Find(&list).Error
	return
}
~~~

~~~go

func (d *MemberWalletDomain) Copy(memberWallet *model.MemberWallet, coinInfo *mclient.Coin) *model.MemberWalletCoin {
	mwc := &model.MemberWalletCoin{}
	copier.Copy(mwc, memberWallet)
	mwc.Coin = &market.Coin{}
	copier.Copy(mwc.Coin, coinInfo)
	if memberWallet.CoinName != "USDT" {
		//获取最新的汇率
		mwc.Coin.UsdRate = 1000
		mwc.Coin.CnyRate = 7
	} else {
		mwc.Coin.UsdRate = 1
		mwc.Coin.CnyRate = 7
	}
	return mwc
}
~~~

## 2. 实时汇率获取

上述需要显示每个币种对应的汇率，所以我们在读取到最新的K线数据时获取其对USDT的汇率存于redis中，同时通过okx获取美元对人民币的汇率，存于redis中

简单一些，我们直接在jobcenter获取到信息 直接存入redis。

### 2.1 人民币汇率

~~~go
type ExchangeRate struct {
	UsdCny string `json:"usdCny"`
}
type OkxRateRes struct {
	Code string          `json:"code"`
	Msg  string          `json:"msg"`
	Data []*ExchangeRate `json:"data"`
}

~~~

~~~go
package market

import (
	"encoding/base64"
	"encoding/json"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/database"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/model"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/svc"
	"log"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/tools"
	"sync"
	"time"
)

type Rate struct {
	wg          sync.WaitGroup
	redisClient *database.RedisClient
}

// Do 获取人民币对美元汇率
func (r *Rate) Do() {
	r.wg.Add(1)
	go r.rateToRedis()
	r.wg.Wait()

}

func (r *Rate) rateToRedis() {
	api := "GET/api/v5/market/exchange-rate"
	timestamp := tools.ISO(time.Now())
	sha256 := tools.ComputeHmacSha256(timestamp+api, secretKey)
	sign := base64.StdEncoding.EncodeToString([]byte(sha256))
	header := make(map[string]string)
	header["OK-ACCESS-KEY"] = "d5a748c6-214d-4fae-bef3-d32368ecbbe8"
	header["OK-ACCESS-SIGN"] = sign
	header["OK-ACCESS-TIMESTAMP"] = timestamp
	header["OK-ACCESS-PASSPHRASE"] = "Mszlu!@#$56789"
	respBody, err := tools.GetWithHeader(
		"https://www.okx.com/api/v5/market/exchange-rate",
		header,
		"http://127.0.0.1:10809")
	if err != nil {
		log.Println(err)
		r.wg.Done()
		return
	}
	//{
	//    "code": "0",
	//    "msg": "",
	//    "data": [ {
	//            "usdCny": "6.44"
	//}]
	//}
	resp := &model.OkxRateRes{}
	err = json.Unmarshal(respBody, resp)
	if err != nil {
		log.Println(err)
		r.wg.Done()
		return
	}
	for _, v := range resp.Data {
		r.redisClient.Cache.Set("USDT::CNY::RATE", v.UsdCny)
	}
	r.wg.Done()
}

func NewRate(sc *svc.ServiceContext) *Rate {
	return &Rate{
		redisClient: sc.RedisClient,
	}
}

~~~

~~~go
type RedisClient struct {
	Cache cache.Cache
}

func NewRedisClient(cc redis.RedisConf) *RedisClient {
	newRedis := redis.MustNewRedis(cc)
	node := cache.NewNode(newRedis, nil, cache.NewStat("github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter"), nil)
	return &RedisClient{
		Cache: node,
	}
}

~~~

~~~yaml
CacheRedis:
  Host: 127.0.0.1:6379
  Type: node
~~~

~~~go
type Config struct {
	Mongo      database.MongoConfig
	Kafka      database.KafkaConfig
	CacheRedis redis.RedisConf
}

~~~

### 2.2 其他币种汇率

~~~go
//redis存一个最新的汇率
					newString := strings.ReplaceAll(instId, "-", "::")
					k.redisClient.Cache.Set(newString+"::RATE", data[4])
~~~

### 2.3 用户钱包获取redis汇率

~~~go
func (d *MemberWalletDomain) Copy(memberWallet *model.MemberWallet, coinInfo *mclient.Coin) *model.MemberWalletCoin {
	mwc := &model.MemberWalletCoin{}
	copier.Copy(mwc, memberWallet)
	mwc.Coin = &market.Coin{}
	copier.Copy(mwc.Coin, coinInfo)
	var cnyRate string
	d.cache.Get("USDT::CNY::RATE", &cnyRate)
	if memberWallet.CoinName != "USDT" {
		//获取最新的汇率
		var usdRate string
		d.cache.Get(memberWallet.CoinName+"::USDT::RATE", &usdRate)
		if usdRate == "" {
			usdRate = "1"
		}
		mwc.Coin.UsdRate = tools.ToFloat64(usdRate)
		mwc.Coin.CnyRate = op.MulN(tools.ToFloat64(usdRate), tools.ToFloat64(cnyRate), 10)
	} else {
		mwc.Coin.UsdRate = 1
		mwc.Coin.CnyRate = tools.ToFloat64(cnyRate)
	}
	return mwc
}
~~~

## 3. BTC地址

如果我们要进行BTC钱包的充值提现等，首先必须有一个钱包地址，类似于：`1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa`，这是BTC的第一个地址，我们可以通过`https://www.blockchain.com/explorer/addresses/btc/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa` 进行查看。

> 所谓的地址，其实就是一个公钥，也就是说地址是通过一系列的加密算法得到的，所以我们就可以通过这样的规则得到一个属于我们的BTC地址

### 3.1 Base58加密

Base58是用于比特币中使用的一种独特的编码方式，主要用于产生比特币的钱包地址。相比的Base64，Base58不使用数字 “0”，字母大写 “O”，字母大写 “I”，和字母小写 “L”，以及 “+” 和 “/” 符号。

设计Base58主要的目的是：避免混淆。在某些字体下，数字0和字母大写O，以及字母大写我和字母小写升会非常相似。 不使用 “+” 和 “/” 的原因是非字母或数字的字符串作为帐号较难被接受。

但是这个base58的计算量比BASE64的计算量多了很多。因为58不是2的整数倍，需要不断用除法去计算。而且长度也比的base64稍微多了一点。

~~~go
package bc

import (
	"bytes"
	"math/big"
)

var b58Alphabet = []byte("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")

// ReverseBytes 字节数组反转
func ReverseBytes(data []byte) {

	for i, j := 0, len(data)-1; i < j; i, j = i+1, j-1 {

		data[i], data[j] = data[j], data[i]
	}
}

func Base58Encode(input []byte) []byte {
	var result []byte
	x := big.NewInt(0).SetBytes(input)
	base := big.NewInt(int64(len(b58Alphabet)))
	zero := big.NewInt(0)
	mod := &big.Int{}
	for x.Cmp(zero) != 0 {
		x.DivMod(x, base, mod)
		result = append(result, b58Alphabet[mod.Int64()])
	}
	ReverseBytes(result)
	for _, b := range input {
		if b == 0x00 {
			result = append([]byte{b58Alphabet[0]}, result...)
		} else {
			break
		}
	}
	return result
}

// Base58Decode Base58转字节数组，解密
func Base58Decode(input []byte) []byte {
	result := big.NewInt(0)
	zeroBytes := 0
	for _, b := range input {
		if b == 0x00 {
			zeroBytes++
		}
	}
	payload := input[zeroBytes:]
	for _, b := range payload {
		charIndex := bytes.IndexByte(b58Alphabet, b)
		result.Mul(result, big.NewInt(58))
		result.Add(result, big.NewInt(int64(charIndex)))
	}
	decoded := result.Bytes()
	//decoded...表示将decoded所有字节追加
	//decoded = append(bytes.Repeat([]byte{byte(0x00)}, zeroBytes), decoded...)
	return decoded
}

~~~

### 3.2 钱包地址生成

前面我们说过钱包地址就是一个公钥，这里有个基本知识就是公钥和私钥是成对出现的。

公钥是由私钥生成，公钥可以对外公开，私钥必须保管好。

~~~go
package bc

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
)

type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

func NewWallet() (*Wallet, error) {
	privateKey, publicKey, err := newKeyPair()
	if err != nil {
		return nil, err
	}
	return &Wallet{privateKey, publicKey}, nil
}

// newKeyPair 通过私钥创建公钥
func newKeyPair() (ecdsa.PrivateKey, []byte, error) {
	//1.椭圆曲线算法生成私钥
	curve := elliptic.P256()
	privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)
	if err != nil {
		return *privateKey, nil, err
	}
    //序列化私钥
	marshalECPrivateKey, _ := x509.MarshalECPrivateKey(privateKey)
	fmt.Println(string(Base58Encode(marshalECPrivateKey)))
	//2.通过私钥生成公钥
	publicKey := append(privateKey.PublicKey.X.Bytes(), privateKey.PublicKey.Y.Bytes()...)
	return *privateKey, publicKey, nil
}

~~~

#### 3.2.1 生成Address

从公钥得到一个地址需要五步走：

1. 公钥经过两次哈希(SHA256+RIPEMD160)得到一个字节数组PubKeyHash

2. PubKeyHash+交易版本Version拼接成一个新的字节数组Version_PubKeyHash

3. 对Version_PubKeyHash进行两次哈希(SHA256)并按照一定规则生成校验和CheckSum

4. Version_PubKeyHash+CheckSum拼接成Version_PubKeyHash_CheckSum字节数组

5. 对Version_PubKeyHash_CheckSum进行Base58编码即可得到地址Address

~~~go
package bc

import (
	"bufio"
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"golang.org/x/crypto/ripemd160"
)

// Version 用于生成地址的版本
const Version = byte(0x00)

// AddressChecksumLen 用于生成地址的校验和位数 
const AddressChecksumLen = 4

type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

func NewWallet() (*Wallet, error) {
	privateKey, publicKey, err := newKeyPair()
	if err != nil {
		return nil, err
	}
	return &Wallet{privateKey, publicKey}, nil
}

// newKeyPair 通过私钥创建公钥
func newKeyPair() (ecdsa.PrivateKey, []byte, error) {
	//1.椭圆曲线算法生成私钥
	curve := elliptic.P256()
	privateKey, err := ecdsa.GenerateKey(curve, rand.Reader)
	if err != nil {
		return *privateKey, nil, err
	}
	//2.通过私钥生成公钥
	publicKey := append(privateKey.PublicKey.X.Bytes(), privateKey.PublicKey.Y.Bytes()...)
	return *privateKey, publicKey, nil
}

// GetAddress 获取钱包地址 根据公钥生成地址
func (wallet *Wallet) GetAddress() []byte {

	//1.使用RIPEMD160(SHA256(PubKey)) 哈希算法，取公钥并对其哈希两次
	ripemd160Hash := Ripemd160Hash(wallet.PublicKey)
	//2.拼接版本
	version_ripemd160Hash := append([]byte{Version}, ripemd160Hash...)
	//3.两次sha256生成校验和
	checkSumBytes := CheckSum(version_ripemd160Hash)
	//4.拼接校验和
	bytes := append(version_ripemd160Hash, checkSumBytes...)

	//5.base58编码
	return Base58Encode(bytes)
}
func (wallet *Wallet) GetPriKey() string {
	//序列化私钥
	marshalECPrivateKey, _ := x509.MarshalECPrivateKey(&wallet.PrivateKey)
	priBlock := pem.Block{
		Type:  "ECD PRIVATE KEY",
		Bytes: marshalECPrivateKey,
	}
	b := bytes.NewBuffer(make([]byte, 0))
	bw := bufio.NewWriter(b)
	err := pem.Encode(bw, &priBlock)
	if err != nil {
		panic(err)
	}
	bw.Flush()
	i := b.Bytes()
	return string(Base58Encode(i))
}
func (wallet *Wallet) ResetPriKey(key string) error {
	//反序列化私钥
	decode := Base58Decode([]byte(key))
	block, _ := pem.Decode(decode)
	privateKey, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		return err
	}
	wallet.PrivateKey = *privateKey
	return nil
}

// Ripemd160Hash 将公钥进行两次哈希
func Ripemd160Hash(publicKey []byte) []byte {
	//1.hash256
	hash256 := sha256.New()
	hash256.Write(publicKey)
	hash := hash256.Sum(nil)

	//2.ripemd160
	ripemd160 := ripemd160.New()
	ripemd160.Write(hash)

	return ripemd160.Sum(nil)
}

// CheckSum 两次sha256哈希生成校验和
func CheckSum(bytes []byte) []byte {

	hash1 := sha256.Sum256(bytes)
	hash2 := sha256.Sum256(hash1[:])

	return hash2[:AddressChecksumLen]
}

// IsValidForAddress 判断地址是否有效
func (wallet *Wallet) IsValidForAddress(address []byte) bool {

	//1.base58解码地址得到版本，公钥哈希和校验位拼接的字节数组
	version_publicKey_checksumBytes := Base58Decode(address)
	//2.获取校验位和version_publicKeHash
	checkSumBytes := version_publicKey_checksumBytes[len(version_publicKey_checksumBytes)-AddressChecksumLen:]
	version_ripemd160 := version_publicKey_checksumBytes[:len(version_publicKey_checksumBytes)-AddressChecksumLen]

	//3.重新用解码后的version_ripemd160获得校验和
	checkSumBytesNew := CheckSum(version_ripemd160)

	//4.比较解码生成的校验和CheckSum重新计算的校验和
	if bytes.Compare(checkSumBytes, checkSumBytesNew) == 0 {
		return true
	}

	return false
}

~~~

~~~go
package bc

import (
	"fmt"
	"testing"
)

func TestNewWallet(t *testing.T) {
	wallet, err := NewWallet()
	if err != nil {
		panic(err)
	}
	address := wallet.GetAddress()
	fmt.Println(string(address))
}

~~~

生成地址：`1PGGsRAjTpHk58sJQ79GRJq2sDqGGdM1ma`

访问: `https://www.blockchain.com/explorer/addresses/btc/1PGGsRAjTpHk58sJQ79GRJq2sDqGGdM1ma`

就可以看到我们的钱包，当然余额是0。

#### 3.2.2 生成测试网络地址

主网我们要使用是需要真实的钱的，在开发环境我们可以使用测试网络来做。

测试网络的地址和正式网络是不一样的，我们需要生成测试网络地址进行使用。

~~~go
// TestVersion 用于生成测试网络地址的版本 3开头
const TestVersion = byte(0x6F)

// P2SHVersion P2SH 类型的地址支持多重签名 m或者n开头
const P2SHVersion = byte(0x05)



// GetAddress 获取钱包地址 根据公钥生成地址
func (wallet *Wallet) GetTestAddress() []byte {

	//1.使用RIPEMD160(SHA256(PubKey)) 哈希算法，取公钥并对其哈希两次
	ripemd160Hash := Ripemd160Hash(wallet.PublicKey)
	//2.拼接版本
	version_ripemd160Hash := append([]byte{TestVersion}, ripemd160Hash...)
	//3.两次sha256生成校验和
	checkSumBytes := CheckSum(version_ripemd160Hash)
	//4.拼接校验和
	bytes := append(version_ripemd160Hash, checkSumBytes...)

	//5.base58编码
	return Base58Encode(bytes)
}
~~~

~~~go

// GetAddress 获取钱包地址 根据公钥生成地址
func (wallet *Wallet) GetTestAddress() []byte {

	//1.使用RIPEMD160(SHA256(PubKey)) 哈希算法，取公钥并对其哈希两次
	ripemd160Hash := Ripemd160Hash(wallet.PublicKey)
	//2.拼接版本
	version_ripemd160Hash := append([]byte{TestVersion}, ripemd160Hash...)
	//3.两次sha256生成校验和
	checkSumBytes := CheckSum(version_ripemd160Hash)
	//4.拼接校验和
	bytes := append(version_ripemd160Hash, checkSumBytes...)

	//5.base58编码
	return Base58Encode(bytes)
}
~~~

~~~shell
mmyTGNJzJvivHJ1iUY3znpyx9H4XAB2ihy
4W1c9imqkKh1r9LNKRhrJLJuvavDJ9NREkbN9HsmMFGPTUGWTAoGsrf9mtz4zZfSo9BM8L7AR32maXwLXnBDqi12RAXFJibspQnMHhSY893VLpC8yXEgX15TyHnVihB8WNtTf9zRsFBnURLwQMgiLChmHxMG9wSGTF8g82dJQyKGSy3Hd9yioJwvToKwMF6upoYwXd8hiqoSdxmndVYEkm5sbVfPr5APP6EP8hP7shABJ79RRCJR2QVeShHq4EoN2YkefypH9MoiKv3WAMRKXbK3fKWAaXC8fFtGA7nD6ypdWrnbk5n6f5nnd
~~~

然后我们去`https://coinfaucet.eu/en/btc-testnet/`去申请一些测试币到这个地址

![image-20230411125436736](img/image-20230411125436736.png)

`https://live.blockcypher.com/btc-testnet/address/mmyTGNJzJvivHJ1iUY3znpyx9H4XAB2ihy/`

![image-20230411130330427](img/image-20230411130330427.png)



我们去另外一个网站：`https://blockstream.info/testnet/address/mmyTGNJzJvivHJ1iUY3znpyx9H4XAB2ihy`

也可以查到此地址的交易信息。



## 4. 地址接口

请求uri： `/uc/asset/wallet/reset-address`

参数：

| 参数         | 类型   | 描述                   |
| ------------ | ------ | ---------------------- |
| x-auth-token | string | header                 |
| unit         | string | form表单 单位 比如 BTC |

返回值：

~~~json
{"code":0,"message":"success","data":null}
~~~



### 4.1 api

~~~go
type AssetReq struct {
	CoinName     string      `json:"coinName,optional" path:"coinName,optional"`
	Ip string `json:"ip,optional"`
	Unit string `json:"unit,optional" form:"unit,optional"`
}
~~~

~~~go
assetGroup.Post("/uc/asset/wallet/reset-address", asset.ResetWalletAddress)
~~~

~~~go

func (h *AssetHandler) ResetWalletAddress(w http.ResponseWriter, r *http.Request) {
	var req = types.AssetReq{}
	if err := httpx.ParseForm(r, &req); err != nil {
		httpx.ErrorCtx(r.Context(), w, err)
		return
	}
	ip := tools.GetRemoteClientIp(r)
	req.Ip = ip
	l := logic.NewAssetLogic(r.Context(), h.svcCtx)
	resp, err := l.ResetWalletAddress(&req)
	result := common.NewResult().Deal(resp, err)
	httpx.OkJsonCtx(r.Context(), w, result)
}
~~~

~~~go

func (l *Asset) ResetWalletAddress(req *types.AssetReq) (string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	value := l.ctx.Value("userId").(int64)
	_, err := l.svcCtx.UAssetRpc.ResetWalletAddress(ctx, &asset.AssetReq{
		UserId:   value,
		CoinName: req.Unit,
	})
	if err != nil {
		return "", err
	}
	return "", nil
}

~~~

### 4.2 rpc

~~~protobuf
message AssetResp {}
service Asset {
  rpc findWalletBySymbol(AssetReq) returns(MemberWallet);
  rpc findWallet(AssetReq) returns(MemberWalletList);
  rpc resetWalletAddress(AssetReq) returns(AssetResp);
}
~~~

~~~go

func (l *AssetLogic) ResetWalletAddress(req *asset.AssetReq) (*asset.AssetResp, error) {
	mw, err := l.memberWalletDomain.FindWalletByMemIdAndCoinName(l.ctx, req.UserId, req.CoinName)
	if err != nil {
		return nil, err
	}
	//BTC的钱包地址逻辑
	if mw.Address == "" && req.CoinName == "BTC" {
		wallet, err := bc.NewWallet()
		if err != nil {
			return nil, err
		}
		address := wallet.GetTestAddress()
		mw.Address = string(address)
		mw.AddressPrivateKey = wallet.GetPriKey()
		err = l.memberWalletDomain.UpdateAddress(l.ctx, mw)
		if err != nil {
			return nil, err
		}
	}
	return &asset.AssetResp{}, nil
}

~~~

~~~go
func (d *MemberWalletDomain) UpdateAddress(ctx context.Context, mw *model.MemberWallet) error {
	return d.memberWalletRepo.UpdateAddress(ctx, mw)
}
~~~

~~~go
type MemberWalletRepo interface {
	Save(ctx context.Context, mw *model.MemberWallet) error
	FindByIdAndCoinName(ctx context.Context, memId int64, coinName string) (mw *model.MemberWallet, err error)
	UpdateFreeze(ctx context.Context, conn msdb.DbConn, memId int64, money float64, symbol string) error
	UpdateBalance(ctx context.Context, wallet *model.MemberWallet) error
	FindByMemId(ctx context.Context, memId int64) ([]*model.MemberWallet, error)
	UpdateAddress(ctx context.Context, mw *model.MemberWallet) error
}

~~~

~~~go

func (m *MemberWalletDao) UpdateAddress(ctx context.Context, mw *model.MemberWallet) error {
	updateSql := "update member_wallet set address=? , address_private_key = ? where id = ?"
	session := m.conn.Session(ctx)
	err := session.Model(&model.MemberWallet{}).Exec(updateSql, mw.Address, mw.AddressPrivateKey, mw.Id).Error
	return err
}
~~~

## 5. 交易记录

请求uri： `/uc/asset/transaction/all`

参数：

| 参数         | 类型   | 描述                                                         |
| ------------ | ------ | ------------------------------------------------------------ |
| x-auth-token | string | header                                                       |
| pageNo       | int    | form表单 当前页                                              |
| pageSize     | int    | form表单 每页显示数量                                        |
| startTime    | string | form表单 开始时间 不是必须                                   |
| endTime      | string | form表单 结束时间 不是必须                                   |
| symbol       | string | form表单 币种名称 比如 BTC  不是必须                         |
| type         | string | form表单 类型  0 RECHARGE 充值类型 1 WITHDRAW 提现类型 不是必须 |

返回值：

~~~json
~~~

### 5.1 sql

~~~sql
CREATE TABLE `member_transaction`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '编号',
  `address` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '充值或提现地址、或转账地址',
  `amount` decimal(18, 8) NOT NULL COMMENT '充币金额',
  `create_time` bigint(0) NOT NULL COMMENT '创建时间',
  `fee` decimal(19, 8) NOT NULL COMMENT '交易手续费',
  `flag` int(0) NOT NULL DEFAULT 0 COMMENT '标识位',
  `member_id` bigint(0) NOT NULL COMMENT '会员ID',
  `symbol` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '币种名称 比如BTC',
  `type` int(0) NOT NULL COMMENT '交易类型',
  `discount_fee` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '折扣手续费',
  `real_fee` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '实收手续费',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = DYNAMIC;
~~~



~~~go
package model

import (
	"github.com/jinzhu/copier"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/enums"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/tools"
)

type MemberTransaction struct {
	Id          int64   `gorm:"column:id"`
	Address     string  `gorm:"column:address"`
	Amount      float64 `gorm:"column:amount"`
	CreateTime  int64   `gorm:"column:create_time"`
	Fee         float64 `gorm:"column:fee"`
	Flag        int     `gorm:"column:flag"`
	MemberId    int64   `gorm:"column:member_id"`
	Symbol      string  `gorm:"column:symbol"`
	Type        int     `gorm:"column:type"`
	DiscountFee string  `gorm:"column:discount_fee"`
	RealFee     string  `gorm:"column:real_fee"`
}

func (*MemberTransaction) TableName() string {
	return "member_transaction"
}

const (
	RECHARGE          = iota // 充值
	WITHDRAW                 // 提现
	TRANSFER_ACCOUNTS        //转账
	EXCHANGE                 //币币交易

)

var TypeMap = enums.Enum{
	RECHARGE:          "RECHARGE",
	WITHDRAW:          "WITHDRAW",
	TRANSFER_ACCOUNTS: "TRANSFER_ACCOUNTS",
	EXCHANGE:          "EXCHANGE",
}

type MemberTransactionVo struct {
	Id          int64   `json:"id" from:"id"`
	Address     string  `json:"address" from:"address"`
	Amount      float64 `json:"amount" from:"amount"`
	CreateTime  string  `json:"createTime" from:"createTime"`
	Fee         float64 `json:"fee" from:"fee"`
	Flag        int     `json:"flag" from:"flag"`
	MemberId    int64   `json:"memberId" from:"memberId"`
	Symbol      string  `json:"symbol" from:"symbol"`
	Type        string  `json:"type" from:"type"`
	DiscountFee string  `json:"discountFee" from:"discountFee"`
	RealFee     string  `json:"realFee" from:"realFee"`
}

func (mt *MemberTransaction) ToVo() *MemberTransactionVo {
	vo := &MemberTransactionVo{}
	copier.Copy(vo, mt)
	vo.CreateTime = tools.ToTimeString(mt.CreateTime)
	vo.Type, _ = TypeMap.Value(mt.Type)
	return vo
}

~~~

### 5.2 api

~~~go

type AssetReq struct {
	CoinName  string `json:"coinName,optional" path:"coinName,optional"`
	Ip        string `json:"ip,optional"`
	Unit      string `json:"unit,optional" form:"unit,optional"`
	PageNo    int    `json:"pageNo,optional" form:"pageNo,optional"`
	PageSize  int    `json:"pageSize,optional" form:"pageSize,optional"`
	StartTime string `json:"startTime,optional" form:"startTime,optional"`
	EndTime   string `json:"endTime,optional" form:"endTime,optional"`
	Symbol    string `json:"symbol,optional" form:"symbol,optional"`
	Type      string `json:"type,optional" form:"type,optional"`
}

type MemberTransaction struct {
	Id          int64   `json:"id" from:"id"`
	Address     string  `json:"address" from:"address"`
	Amount      float64 `json:"amount" from:"amount"`
	CreateTime  string  `json:"createTime" from:"createTime"`
	Fee         float64 `json:"fee" from:"fee"`
	Flag        int     `json:"flag" from:"flag"`
	MemberId    int64   `json:"memberId" from:"memberId"`
	Symbol      string  `json:"symbol" from:"symbol"`
	Type        string  `json:"type" from:"type"`
	DiscountFee string  `json:"discountFee" from:"discountFee"`
	RealFee     string  `json:"realFee" from:"realFee"`
}

~~~

~~~go
assetGroup.Post("/uc/asset/transaction/all", asset.FindTransaction)
~~~

~~~go

func (h *AssetHandler) FindTransaction(w http.ResponseWriter, r *http.Request) {
	var req = types.AssetReq{}
	if err := httpx.ParseForm(r, &req); err != nil {
		httpx.ErrorCtx(r.Context(), w, err)
		return
	}
	ip := tools.GetRemoteClientIp(r)
	req.Ip = ip
	l := logic.NewAssetLogic(r.Context(), h.svcCtx)
	resp, err := l.FindTransaction(&req)
	result := common.NewResult().Deal(resp, err)
	httpx.OkJsonCtx(r.Context(), w, result)
}
~~~

~~~go

func (l *Asset) FindTransaction(req *types.AssetReq) (*pages.PageResult, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	value := l.ctx.Value("userId").(int64)
	mts, err := l.svcCtx.UAssetRpc.FindTransaction(ctx, &asset.AssetReq{
		UserId:    value,
		StartTime: req.StartTime,
		EndTime:   req.EndTime,
		Type:      req.Type,
		Symbol:    req.Symbol,
		PageNo:    int64(req.PageNo),
		PageSize:  int64(req.PageSize),
	})
	if err != nil {
		return nil, err
	}
	var resp []*types.MemberTransaction
	if err := copier.Copy(&resp, mts.List); err != nil {
		return nil, err
	}
	if resp == nil {
		resp = []*types.MemberTransaction{}
	}
	b := make([]any, len(resp))
	for i := range resp {
		b[i] = resp[i]
	}
	return pages.New(b, int64(req.PageNo), int64(req.PageSize), mts.Total), nil
}
~~~



### 5.3 rpc

~~~protobuf
message AssetReq {
  string coinName = 1;
  string ip = 2;
  int64 userId = 3;
  string startTime = 4;
  string endTime = 5;
  int64 pageNo = 6;
  int64 pageSize = 7;
  string type = 8;
  string symbol = 9;
}

message MemberTransaction{
  int64 id  = 1;
  string address  = 2;
  double amount  = 3;
  string createTime  = 4;
  double fee  = 5;
  int32 flag  = 6;
  int64 memberId  = 7;
  string symbol  = 8;
  string type  = 9;
  string discountFee  = 10;
  string realFee  = 11;
}

message MemberTransactionList {
  repeated MemberTransaction list = 1;
    int64 total = 2;
}
message AssetResp {}
service Asset {
  rpc findWalletBySymbol(AssetReq) returns(MemberWallet);
  rpc findWallet(AssetReq) returns(MemberWalletList);
  rpc resetWalletAddress(AssetReq) returns(AssetResp);
  rpc findTransaction(AssetReq) returns(MemberTransactionList);
}
~~~

~~~go
func (s *AssetServer) FindTransaction(ctx context.Context, in *asset.AssetReq) (*asset.MemberTransactionList, error) {
	l := logic.NewAssetLogic(ctx, s.svcCtx)
	return l.FindTransaction(in)
}
~~~

~~~go
package logic

import (
	"context"
	"github.com/jinzhu/copier"
	"github.com/zeromicro/go-zero/core/logx"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/bc"
	"ffcoin/grpc-common/market/market"
	"ffcoin/grpc-common/ucenter/asset"
	"ffcoin/ucenter/internal/domain"
	"ffcoin/ucenter/internal/model"
	"ffcoin/ucenter/internal/svc"
)

type AssetLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
	memberDomain            *domain.MemberDomain
	memberWalletDomain      *domain.MemberWalletDomain
	memberTransactionDomain *domain.MemberTransactionDomain
}


func (l *AssetLogic) FindTransaction(req *asset.AssetReq) (*asset.MemberTransactionList, error) {
	mms, err := l.memberTransactionDomain.FindTransaction(
		l.ctx,
		req.PageNo,
		req.PageSize,
		req.UserId,
		req.Symbol,
		req.StartTime,
		req.EndTime,
		req.Type)
	if err != nil {
		return nil, err
	}
	var mts []*asset.MemberTransaction
	copier.Copy(&mts, mms)
	return &asset.MemberTransactionList{
		List: mts,
	}, nil
}

func NewAssetLogic(ctx context.Context, svcCtx *svc.ServiceContext) *AssetLogic {
	return &AssetLogic{
		ctx:                     ctx,
		svcCtx:                  svcCtx,
		Logger:                  logx.WithContext(ctx),
		memberDomain:            domain.NewMemberDomain(svcCtx.Db),
		memberWalletDomain:      domain.NewMemberWalletDomain(svcCtx.Db, svcCtx.Cache),
		memberTransactionDomain: domain.NewMemberTransactionDomain(svcCtx.Db),
	}
}

~~~

~~~go
package domain

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"ffcoin/ucenter/internal/dao"
	"ffcoin/ucenter/internal/model"
	"ffcoin/ucenter/internal/repo"
)

type MemberTransactionDomain struct {
	memberTransactionRepo repo.MemberTransactionRepo
}
func (d *MemberTransactionDomain) FindTransaction(
	ctx context.Context,
	pageNo int64,
	pageSize int64,
	userId int64,
	symbol string,
	startTime string,
	endTime string,
	t string) ([]*model.MemberTransactionVo, int64, error) {
	list, total, err := d.memberTransactionRepo.FindTransaction(ctx, int(pageNo), int(pageSize), userId, startTime, endTime, symbol, t)
	if err != nil {
		return nil, total, err
	}
	var voList = make([]*model.MemberTransactionVo, len(list))
	for i, v := range list {
		voList[i] = v.ToVo()
	}
	return voList, total, nil
}

func NewMemberTransactionDomain(db *msdb.MsDB) *MemberTransactionDomain {
	return &MemberTransactionDomain{
		memberTransactionRepo: dao.NewMemberTransactionDao(db),
	}
}

~~~

~~~go
package repo

import (
	"context"
	"ffcoin/ucenter/internal/model"
)

type MemberTransactionRepo interface {
	FindTransaction(
		ctx context.Context,
		pageNo int,
		pageSize int,
		memberId int64,
		startTime string,
		endTime string,
		symbol string,
		transactionType string) (list []*model.MemberTransaction, total int64, err error)
}

~~~

~~~go
package dao

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb/gorms"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/tools"
	"ffcoin/ucenter/internal/model"
)

type MemberTransactionDao struct {
	conn *gorms.GormConn
}

func (d *MemberTransactionDao) FindTransaction(
	ctx context.Context,
	pageNo int,
	pageSize int,
	memberId int64,
	startTime string,
	endTime string,
	symbol string,
	transactionType string) (list []*model.MemberTransaction, total int64, err error) {
	session := d.conn.Session(ctx)
	db := session.Model(&model.MemberTransaction{}).Where("member_id=?", memberId)
	if transactionType != "" {
		db.Where("type=?", tools.ToInt64(transactionType))
	}
	if startTime != "" && endTime != "" {
		sTime := tools.ToMill(startTime)
		eTime := tools.ToMill(endTime)
		db.Where("create_time >= ? and create_time <= ?", sTime, eTime)
	}
	if symbol != "" {
		db.Where("symbol=?", symbol)
	}
	offset := (pageNo - 1) * pageSize
	db.Count(&total)
	db.Order("create_time desc").Offset(offset).Limit(pageSize)
	err = db.Find(&list).Error
	return
}
func NewMemberTransactionDao(db *msdb.MsDB) *MemberTransactionDao {
	return &MemberTransactionDao{
		conn: gorms.New(db.DB),
	}
}

~~~

## 6. 获取虚拟币交易记录

当给地址充值后，我们如何知道充值数据呢？

* 给地址充值后，需要将其提交到网络，需要旷工将其打包到区块，多节点确认后，交易才能生效
* 有一定的延时性，不是立即到账，转账需要给旷工付费（手续费）

充值步骤：

* 找一个有钱的BTC账户向你的账户进行转账（我们用测试网络，用教程上述方式进行充值）
* 安装bitcoin，下载地址: `https://bitcoincore.org/zh_CN/releases/`
* 安装，安装后找到安装地址下的`C:\Bitcoin\daemon\bitcoind.exe`
* 使用如下命令进行启动, `bitcoind -rpcuser=bitcoin -rpcpassword=123456 --txindex -conf=c:/Bitcoin/bitcoin.conf --testnet`
* 上述命令就是开启测试网络，会拉取测试网络全节点数据，需要一段时间
* 上述就相当于开启了一个联网的bitcoin服务，我们通过这个服务进行查询，交易等

> 那怎么访问bitcoin服务呢？
>
> bitcoin给我们提供了rpc api，地址: `https://developer.bitcoin.org/reference/rpc/index.html` 或者`https://bitcoincore.org/en/doc/24.0.0/`

步骤:

* 访问`getmininginfo`得到区块高度
* 访问`getblockhash`，传递区块高度，得到区块hash
* 访问`getblock`，传递区块hash，得到此区块的交易id
* 访问`getrawtransaction`, 传递交易id，得到交易详情
  * vin  input  张三 2 BTC （input中的txid 查询到此交易的vout信息中拿到）
  * vout  output   李四 0.5BTC （unspend transaction output UTXO） 张三 1.5BTC  (张三 1.5BTC input spend)

* 匹配交易中是否有对系统地址的交易，有则进行记录

### 6.1 接口说明

#### getmininginfo

访问地址：POST  `http://127.0.0.1:18332`

参数： 

| 参数          | 类型   | 描述                                                         |
| ------------- | ------ | ------------------------------------------------------------ |
| Authorization | string | header `Basic Yml0Y29pbjoxMjM0NTY=`   使用`rpcuser:rpcpassword` base64加密 |

~~~json
{
    "jsonrpc": "1.0",
    "method": "getmininginfo",
    "params":[],
    "id": "ffcoin"
}
~~~

返回值：

~~~json
{
    "result": {
        "blocks": 2428588, //区块数量
        "difficulty": 104649090.3850967, //出块难度
        "networkhashps": 560392435314242.7, //全网hash生成速率
        "pooledtx": 145, //内存交易池中的交易数量
        "chain": "test", //当前所连接网络
        "warnings": "Unknown new rules activated (versionbit 28)"
    },
    "error": null,
    "id": "ffcoin"
}
~~~

> 一般十分钟生成一个区块

#### getblockhash

访问地址：POST  `http://127.0.0.1:18332`

参数： 

| 参数          | 类型   | 描述                                                         |
| ------------- | ------ | ------------------------------------------------------------ |
| Authorization | string | header `Basic Yml0Y29pbjoxMjM0NTY=`   使用`rpcuser:rpcpassword` base64加密 |

~~~json
{
    "jsonrpc": "1.0",
    "method": "getblockhash",
    "params":[2428588],
    "id": "ffcoin"
}
~~~

返回值：

~~~json
{
    "result": "000000000000000ea27404bc9a0426838c03a07e38cadf4584712d6e618a3e0d",
    "error": null,
    "id": "ffcoin"
}
~~~

#### getblock

访问地址：POST  `http://127.0.0.1:18332`

参数： 

| 参数          | 类型   | 描述                                                         |
| ------------- | ------ | ------------------------------------------------------------ |
| Authorization | string | header `Basic Yml0Y29pbjoxMjM0NTY=`   使用`rpcuser:rpcpassword` base64加密 |

~~~json
{
    "jsonrpc": "1.0",
    "method": "getblock",
    "params":["000000000000000ea27404bc9a0426838c03a07e38cadf4584712d6e618a3e0d",1],
    "id": "ffcoin"
}
{
    "jsonrpc": "1.0",
    "method": "getblock",
    "params":["000000000000000ea27404bc9a0426838c03a07e38cadf4584712d6e618a3e0d",2],
    "id": "ffcoin"
}
~~~

* 1 ： json格式
* 2： json格式，同时解码区块中的交易

返回值：

~~~json
{
    "result": {
        "hash": "000000000000000ea27404bc9a0426838c03a07e38cadf4584712d6e618a3e0d", //区块哈希
        "confirmations": 2, //确认数
        "height": 2428588, //区块高度
        "version": 549453824, //版本
        "versionHex": "20c00000", //16进制表示的版本
        "merkleroot": "05bee39423249aa4ad7c5e2dd449161255b54808dc11667e1804cd089a22e6e0", //区块的默克尔树根
        "time": 1681290448, //区块创建时间戳
        "mediantime": 1681285778, //区块中值时间戳
        "nonce": 2288573738,
        "bits": "19290a7e",
        "difficulty": 104649090.3850967, //难度
        "chainwork": "0000000000000000000000000000000000000000000009709e634fb9148fb477",
        "nTx": 62,
        "previousblockhash": "00000000bd1774cf6209b4e2bccd7e5e653c1efe88e7593ad912871bf48521d7", //前一区块的哈希
        "nextblockhash": "000000000000000f15d7e4a67c0221e9cef7f7a2152c19ee2df8f99d3c60bc77", //下一区块的哈希
        "strippedsize": 9775,
        "size": 31621,
        "weight": 60946,
        "tx": [ //区块内所有交易组成的数组，成员为交易id
            "4dff3d7605f7e94d122007100064d67627a6493ecf3ee67b0049c520a18673c1",
            "cc27fc1b54bd62ce8e2d0d44a16d8f001213bbccd992d194c719f55de54e2f07",
            "9511f41d9cb96978bde8a9854d727ff68a7afe83411c878d446256a60940372f",
            "d296a356439ff369fb02460948322086d89ff979e740e4cba8e795a4892aeb2f",
            "11a465360cb75f5434cbef49793c89d24d198ca8aef419a24352d55c628ff748",
            "1821ca4ab4134fc8a9cb2092466a64e26f48028caf2f719810c6179a5e97f48e",
            "33e878b40d51dda2cf2cf0a21ce14831b9a2593bdd833765abc90d36c26e4750",
            "384943d5a4bb2bdef7748e6b4071c9b39170be82c5e4f1e2e72acaeb20503a57",
            "121d509017ba2dc170bd9a9fb71473728cf1bfa5ba5de5522ea6bef4294be48c",
            "b2890ec795728bdf038f83e90b9d31fefa8b7cbf99df45ae760bf783f7e3d394",
            "d7c3c042ba37b0a7f838c39c7a07b484e40ffc37766f2be3d79cd6d522dbcaf2",
            "15eaefae93e03476963ec701b7ca5cd5b77017be4aadee3cf1ddb831a7147496",
            "428c919fe6b6ab73cd77e4388daf0ef038a97222b8e2ecfb1c5a49ded8ab58dc",
            "7fcf5ce93e4aea5ad82f0dd7a020309dac44c5305e539cf1f97a78f02ae11fdd",
            "056240bead3c19989dc481d5daf221d0dda44d2ff68e0ef9af744529e7a3f6fe",
            "320d4468a3ba1ab5a2cf852e7552747c32ffc5f921b39522fefad10db5de2b2b",
            "9bd51f2513d47b10f51c698184fa13e77ab26089001b652f549cc5d6e318604c",
            "8f129fd3fb0458ed924486c48d23e2aa905ebfdd705d9d37806d021923b4f54c",
            "bf4e26a11d52d73977f917845ed785d55e1cee10cfab0016a8fc879b5c8b4869",
            "372d653ffdcf7d4877f3379215eb298d101f27040dfee94fbd798530517be781",
            "1701bfa92d32bad9a5aed1943d29cdea7d5fd83003552ba7aebb1f193094e5f7",
            "d21baad8ed48a10c0232a99f28eecd2517f115569fff867931b895d9edb98039",
            "7fe1d11ce9dab2294ba33cf62146fc7df2a41290cee775723eeaf67c5ad26087",
            "a7a362ad4bcdca1f1629886adf5b2785d553b7823a34e833bd4ec906863adfc5",
            "79a9bec9289e497a387c23e6faa50e029d65c1c6113146492cec7a4697ad7275",
            "f1914ce8881aae16c7cf0a7e3bad3aae6a79521965ab67fdb1e4b07a40091cb9",
            "24f285877cc092d1ffccf1c730ab934544cad512766b810968cb5e681086448d",
            "d4fab2e9bf72ade87e00a68033c07397ee3a5ce461dd3274068c9c6821532bd2",
            "b4cc9525d83f5baf506c4b03d7f39267222eb57719b1c35437f20306ef87a41f",
            "f71fc9790cef10934adcbcc52f12cb45e0725bc4bf4ee08d1d1957ebd40d984b",
            "9848ac81b85e11153cf4731e02af5ecc04dfbd3593fe8da9af0699d05dc08477",
            "a7ab888b84cebb4efcc1f25aacd981283438adf91be4245bd35fa21dc04ac311",
            "0879ac075305a5fd27f8a088d9e97327b01740f374f494b0054343b96099581a",
            "9bf8ea7ff9418a6d7ede5105782fda85451df00c7c092e69451d5ad286cd81cb",
            "ea34e3a3e8a220bf1351f1b0d216162f7610f7810110932d2d990c3edad87334",
            "41007a8e10e18accb40930b966083374bb7fc6d616e9b5a33a4588e19a6d7e67",
            "8d898476b1903b04f33e538ae31ffbb6d311ed608c26d812d8fa048a0fca416e",
            "3d81df810a9182551152d243eaf9680a95126b995bdf627b7800556708730e2d",
            "0976585773c7655310950f3ec4c91229e95e50791a36e8a91e8f96e4c41967d9",
            "c961828de80cec0c83c367ff7eba72e7f898b232056fe0aaccd7aa6002da232b",
            "03d4f996c28065686f3a824792a97b25918fe931b23ef5a83fc7728ab7dc0ae4",
            "dc6838614a63328bd467301cccbe54f53bcb2daeadcf0ed5f0295beda597b99a",
            "7cad33a08eef89ff5d8824226656c7e099150233da17b919cb9c8f31c4b013eb",
            "3fd34770e812bd57f9d78425351c385ef287214f30fb762a386841d48332cc8f",
            "46095981de4a4c77afd92757ae4c5191641ef8b9da48f25befaa9d7b57b573d7",
            "80949ab54c442960a286b979b1690be5e3bc005aff351acabe6bfab22b410814",
            "8660c7a24dd40771573367aabea2275bf05dc2b23880a0a5144fec73a5d75c7b",
            "961ec728e6b756340290f49456c292ca4663dda07ca2cb6e13bcf2612de8ed7e",
            "ee8a93fd0b95f269602b7a87dae34362024b64448045c150dc982c7032a7b781",
            "9fb7993ca112be5453b6e28f6c216f2555da231e65fcf573bf5b862ed7947086",
            "bd93bcb3a14ef55dccff101bd0700a0e622971f92680f89e6193007406241e9d",
            "858345f9a85e201a83d23973eb3c7d7d7403d107744b831f634a009a15bf49a2",
            "8fceeb9e9d2e5ae1d137ff468a24fd98bd3f2a09891286d24fb7b5f8af12e7b0",
            "fbdb0504dd700fb2788c0803928af2e3ad03a13128075c7afca66c9b9ed6fbb3",
            "af1c3d3170b5e5cde30be0fab298820e095b35bf008719c8817e8b5ad206c1be",
            "fe90dbfa9a40748e7ebb9d89eade88f346ec399a7df54910e5657f814c129ec7",
            "b7b2aee95dd7be73fd4218b9eeb67c359dd74675abb882baca2d33ee9d8400c8",
            "2d20e3215e51369cfbe24fb1d74391fb51e00303ce5bc4cd888aa887c49ac9c9",
            "a74388751c0658c9edc75b6f70183b3a1fc78d0ba7d8aab3e6981c8257e12ece",
            "a64aea9604ad7f77321355ff8b28689e9d3d446d288deadbffec652975ffd2d2",
            "f581138ba0fb8ab64f0c1dbd6acd81290c123fa7fc7ee28b5d836aa9b27bd9d4",
            "b4ef2fb7e489ab85fa8dd64da452d1a26d4aec39f31dfb21c82bca31dd6ffaf1"
        ]
    },
    "error": null,
    "id": "ffcoin"
}
~~~

#### getrawtransaction

访问地址：POST  `http://127.0.0.1:18332`

参数： 

| 参数          | 类型   | 描述                                                         |
| ------------- | ------ | ------------------------------------------------------------ |
| Authorization | string | header `Basic Yml0Y29pbjoxMjM0NTY=`   使用`rpcuser:rpcpassword` base64加密 |

~~~json
{
    "jsonrpc": "1.0",
    "method": "getrawtransaction",
    "params":["f42572a8e565a59c7b5212df4de1590f3bcd0a2707609a0b4b31168ab354c70f",true],
    "id": "ffcoin"
}
~~~

返回值：

~~~json
{
    "result": {
        "txid": "f42572a8e565a59c7b5212df4de1590f3bcd0a2707609a0b4b31168ab354c70f",
        "hash": "affc3afc17b3d63d94ac67293dafb2eb004c8fc1e0b1187f8682fc96b300ea64",
        "version": 2,
        "size": 228,
        "vsize": 147,
        "weight": 585,
        "locktime": 2428426,
        //张三的2个BTC从哪里来的？ 一定是从一个交易中来 input是其他交易的ouput
        //vin input  举一个例子 张三 2个 BTC 转账给李四 0.5个BTC 
        // input就是 张三 2个BTC 
        //output 就是李四 0.5个BTC 张三 1.5个BTC 
        //vin input  举一个例子 张三 2个 BTC 转账给李四 0.5个BTC 王五 1.5个BTC
        // input就是 张三 2个BTC 
        //output 就是李四 0.5个BTC 王五 1.5个BTC
        "vin": [
            {
                "txid": "d22b13c5bc59c8bb401400d268e271a9a2d0ccaeb759e029b98793e8ddbd2c70",
                "vout": 1,
                "scriptSig": {
                    "asm": "",
                    "hex": ""
                },
                "txinwitness": [
                    "304402205e2fa047f40b57c52a35e5f0bc8c7175542b11edc4a29d29298530c86073d62c022076669187267892d25ae8398406b0940acab7d887557bcdf738d9e5d93b9aacad01",
                    "02409348e31e1c76376ebb9db9030951afb0aa3fa82153a0a12c9f7c345d32a561"
                ],
                "sequence": 4294967294
            }
        ],
        //unspend transaction output
        //UTXO 很重要的概念 区块链上所有的UTXO加起来就是总和
        //一个address的所有UTXO加起来就是 余额
        "vout": [
            {
                "value": 0.02931889,
                "n": 0,
                "scriptPubKey": {
                    "asm": "OP_DUP OP_HASH160 46d3c0e0a13e89256bd255f015a14fbf29f5e06f OP_EQUALVERIFY OP_CHECKSIG",
                    "desc": "addr(mmyTGNJzJvivHJ1iUY3znpyx9H4XAB2ihy)#vk04dhee",
                    "hex": "76a91446d3c0e0a13e89256bd255f015a14fbf29f5e06f88ac",
                    "address": "mmyTGNJzJvivHJ1iUY3znpyx9H4XAB2ihy",
                    "type": "pubkeyhash"
                }
            },
            {
                "value": 70.87631046,
                "n": 1,
                "scriptPubKey": {
                    "asm": "OP_DUP OP_HASH160 069e92d719a43538fea3654539b20c960a8a2618 OP_EQUALVERIFY OP_CHECKSIG",
                    "desc": "addr(mg7xK6G7qspHytqak4DWivCuizxE1i45hY)#c22xf39h",
                    "hex": "76a914069e92d719a43538fea3654539b20c960a8a261888ac",
                    "address": "mg7xK6G7qspHytqak4DWivCuizxE1i45hY",
                    "type": "pubkeyhash"
                }
            }
        ],
        "hex": "02000000000101702cbddde89387b929e059b7aeccd0a2a971e268d2001440bbc859bcc5132bd20100000000feffffff02b1bc2c00000000001976a91446d3c0e0a13e89256bd255f015a14fbf29f5e06f88acc6aa74a6010000001976a914069e92d719a43538fea3654539b20c960a8a261888ac0247304402205e2fa047f40b57c52a35e5f0bc8c7175542b11edc4a29d29298530c86073d62c022076669187267892d25ae8398406b0940acab7d887557bcdf738d9e5d93b9aacad012102409348e31e1c76376ebb9db9030951afb0aa3fa82153a0a12c9f7c345d32a5610a0e2500",
        "blockhash": "000000006afe428edf24fb68e823adae2c9e40b986c7c087e6b486a3a383328b",
        "confirmations": 164,
        "time": 1681189551,
        "blocktime": 1681189551
    },
    "error": null,
    "id": "ffcoin"
}
~~~

> 如果解析出的收款方中的address出现我们系统的地址，进行保存，这就是当前地址的充值记录



### 6.2 实现

~~~go
//十分钟生成一个区块
	t.s.Every(10).Minute().Do(func() {
		logic.NewBitCoin(t.ctx.Cache, t.ctx.AssetRpc, t.ctx.MongoClient, t.ctx.KafkaClient).Do()
	})
~~~

~~~go
package logic

import (
	"context"
	"encoding/json"
	"errors"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/LCY2013/blockchain/exchange/ff-coin/grpc-common/ucenter/types/asset"
	"github.com/LCY2013/blockchain/exchange/ff-coin/grpc-common/ucenter/ucclient"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/database"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/domain"
	"log"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/tools"
	"sync"
)

type BitCoin struct {
	wg            sync.WaitGroup
	ch            cache.Cache
	assetRpc      ucclient.Asset
	bitCoinDomain *domain.BitCoinDomain
	queueDomain   *domain.QueueDomain
}

// Do 扫描BTC交易 查找符合系统address的交易 进行存储
func (b *BitCoin) Do() {
	b.wg.Add(1)
	go b.ScanTx()
	b.wg.Wait()

}

func (b *BitCoin) ScanTx() {
	//1. redis查询是否有记录区块，获取到已处理的区块高度 dealBlocks
	var dealBlocksStr string
	b.ch.Get("BTC::TX", &dealBlocksStr)
	var dealBlocks int64
	if dealBlocksStr == "" {
		dealBlocks = 2428713
	} else {
		dealBlocks = tools.ToInt64(dealBlocksStr)
	}
	//2. 根据getmininginfo获取到现在的区块高度 currentBlocks
	currentBlocks, err := b.getMiningInfo()
	if err != nil {
		log.Println(err)
		b.wg.Done()
		return
	}
	//3. 根据currentBlocks-dealBlocks 如果小于等于0 不需要扫描
	diff := currentBlocks - dealBlocks
	if diff <= 0 {
		b.wg.Done()
		return
	}
	//4. 获取系统中的BTC的address列表
	ctx := context.Background()
	address, err := b.assetRpc.GetAddress(ctx, &asset.AssetReq{
		CoinName: "BTC",
	})
	if err != nil {
		log.Println(err)
		b.wg.Done()
		return
	}
	addressList := address.List
	//5. 循环 根据getblockhash 获取 blockhash
	for i := currentBlocks; i > dealBlocks; i-- {
		blockHash, err := b.getBlockHash(i)
		if err != nil {
			log.Println(err)
			b.wg.Done()
			continue
		}
		//6. 通过getblock 获取 交易id列表
		txIdList, err := b.getBlock(blockHash)
		if err != nil {
			log.Println(err)
			b.wg.Done()
			continue
		}
		//7. 循环交易id列表 获取到交易详情 得到 vout内容
		for _, txId := range txIdList {
			txResult, err := b.getRawTransaction(txId)
			if err != nil {
				log.Println(err)
				b.wg.Done()
				continue
			}

			inputAddressList := make([]string, len(txResult.Vin))
			for i, vin := range txResult.Vin {
				if vin.Txid == "" {
					continue
				}
				inputTx, err := b.getRawTransaction(vin.Txid)
				if err != nil {
					log.Println(err)
					b.wg.Done()
					continue
				}
				vout := inputTx.Vout[vin.Vout]
				inputAddressList[i] = vout.ScriptPubKey.Address
			}
			//8. 根据vout中的address和上方address列表进行匹配，如果匹配，我们认为是充值
			for _, vout := range txResult.Vout {
				voutAddress := vout.ScriptPubKey.Address
				flag := false
				//9. 做一个处理，根据vint的交易 查询input的address，
				//   如果address和vout当中和系统匹配的address一样，我们认为不是充值  2 0.5 1.5
				for _, inputAddress := range inputAddressList {
					if inputAddress != "" && voutAddress != "" && inputAddress == voutAddress {
						flag = true
					}
				}
				if flag {
					continue
				}
				for _, address := range addressList {
					if address != "" && address == voutAddress {
						//匹配上了 //10. 找到充值数据，存入mongo，同时发送kafka进行下一步处理（存入member_transaction表）
						//充值
						err := b.bitCoinDomain.Recharge(txResult.TxId, vout.Value, voutAddress, txResult.Time, txResult.Blockhash)
						if err != nil {
							log.Println(err)
							b.wg.Done()
							continue
						}
						//kafka处理
						b.queueDomain.SendRecharge(vout.Value, voutAddress, txResult.Time)
					}
				}

			}
		}

	}

	//11. 记录redis的区块高度
	b.ch.Set("BTC::TX", currentBlocks)
	b.wg.Done()
}

//	{
//	   "result": {
//	       "blocks": 2428737,
//	       "difficulty": 104649090.3850967,
//	       "networkhashps": 440403219589005.6,
//	       "pooledtx": 216,
//	       "chain": "test",
//	       "warnings": "Unknown new rules activated (versionbit 28)"
//	   },
//	   "error": null,
//	   "id": "ffcoin"
//	}
type MiningInfoResult struct {
	Id     string     `json:"id"`
	Error  string     `json:"error"`
	Result MiningInfo `json:"result"`
}
type MiningInfo struct {
	Blocks        int     `json:"blocks"`
	Difficulty    float64 `json:"difficulty"`
	Networkhashps float64 `json:"networkhashps"`
	Pooledtx      int     `json:"pooledtx"`
	Chain         string  `json:"chain"`
	Warnings      string  `json:"warnings"`
}

func (b *BitCoin) getMiningInfo() (int64, error) {
	//{
	//    "jsonrpc": "1.0",
	//    "method": "getmininginfo",
	//    "params":[],
	//    "id": "ffcoin"
	//}
	params := make(map[string]any)
	params["jsonrpc"] = "1.0"
	params["method"] = "getmininginfo"
	params["params"] = []int{}
	params["id"] = "ffcoin"
	headers := make(map[string]string)
	headers["Authorization"] = "Basic Yml0Y29pbjoxMjM0NTY="
	bytes, err := tools.PostWithHeader("http://127.0.0.1:18332", params, headers, "")
	if err != nil {
		return 0, err
	}
	var result MiningInfoResult
	json.Unmarshal(bytes, &result)
	if result.Error != "" {
		return 0, errors.New(result.Error)
	}
	return int64(result.Result.Blocks), nil
}

type BlockHashResult struct {
	Id     string `json:"id"`
	Error  string `json:"error"`
	Result string `json:"result"`
}

func (b *BitCoin) getBlockHash(height int64) (string, error) {
	params := make(map[string]any)
	params["jsonrpc"] = "1.0"
	params["method"] = "getblockhash"
	params["params"] = []int64{height}
	params["id"] = "ffcoin"
	headers := make(map[string]string)
	headers["Authorization"] = "Basic Yml0Y29pbjoxMjM0NTY="
	bytes, err := tools.PostWithHeader("http://127.0.0.1:18332", params, headers, "")
	if err != nil {
		return "", err
	}
	var result BlockHashResult
	json.Unmarshal(bytes, &result)
	if result.Error != "" {
		return "", errors.New(result.Error)
	}
	return result.Result, nil
}

type BlockResult struct {
	Id     string      `json:"id"`
	Error  string      `json:"error"`
	Result BlockSimple `json:"result"`
}
type BlockSimple struct {
	Hash string   `json:"hash"`
	Tx   []string `json:"tx"`
	Time int64    `json:"time"`
}

func (b *BitCoin) getBlock(blockHash string) ([]string, error) {
	params := make(map[string]any)
	params["jsonrpc"] = "1.0"
	params["method"] = "getblock"
	params["params"] = []any{blockHash, 1}
	params["id"] = "ffcoin"
	headers := make(map[string]string)
	headers["Authorization"] = "Basic Yml0Y29pbjoxMjM0NTY="
	bytes, err := tools.PostWithHeader("http://127.0.0.1:18332", params, headers, "")
	if err != nil {
		return nil, err
	}
	var result BlockResult
	json.Unmarshal(bytes, &result)
	if result.Error != "" {
		return nil, errors.New(result.Error)
	}
	return result.Result.Tx, nil
}

type RawTransactionResult struct {
	Id     string         `json:"id"`
	Error  string         `json:"error"`
	Result RawTransaction `json:"result"`
}
type RawTransaction struct {
	TxId      string `json:"txid"`
	Hash      string `json:"hash"`
	Locktime  int64  `json:"locktime"`
	Version   int    `json:"version"`
	Size      int    `json:"size"`
	Vsize     int    `json:"vsize"`
	Weight    int    `json:"weight"`
	Vin       []Vin  `json:"vin"`
	Vout      []Vout `json:"vout"`
	Time      int64  `json:"time"`
	Hex       string `json:"hex"`
	Blocktime int64  `json:"blocktime"`
	Blockhash string `json:"blockhash"`
}

type Vin struct {
	Txid        string            `json:"txid"`
	Vout        int               `json:"vout"`
	Txinwitness []string          `json:"txinwitness"`
	Sequence    int64             `json:"sequence"`
	ScriptSig   map[string]string `json:"scriptSig"`
}

type Vout struct {
	Value        float64      `json:"value"`
	N            int          `json:"n"`
	ScriptPubKey ScriptPubKey `json:"scriptPubKey"`
}
type ScriptPubKey struct {
	Asm     string `json:"asm"`
	Desc    string `json:"desc"`
	Hex     string `json:"hex"`
	Address string `json:"address"`
	Type    string `json:"type"`
}

func (b *BitCoin) getRawTransaction(txId string) (*RawTransaction, error) {
	params := make(map[string]any)
	params["jsonrpc"] = "1.0"
	params["method"] = "getrawtransaction"
	params["params"] = []any{txId, true}
	params["id"] = "ffcoin"
	headers := make(map[string]string)
	headers["Authorization"] = "Basic Yml0Y29pbjoxMjM0NTY="
	bytes, err := tools.PostWithHeader("http://127.0.0.1:18332", params, headers, "")
	if err != nil {
		return nil, err
	}
	var result RawTransactionResult
	json.Unmarshal(bytes, &result)
	if result.Error != "" {
		return nil, errors.New(result.Error)
	}
	return &result.Result, nil
}

func NewBitCoin(ch cache.Cache, assetRpc ucclient.Asset, client *database.MongoClient, kafkaClient *database.KafkaClient) *BitCoin {
	return &BitCoin{
		ch:            ch,
		assetRpc:      assetRpc,
		bitCoinDomain: domain.NewBitCoinDomain(client),
		queueDomain:   domain.NewQueueDomain(kafkaClient),
	}
}

~~~

~~~go
package domain

import (
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/dao"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/database"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/model"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/repo"
)

type BitCoinDomain struct {
	btcTransactionRepo repo.BtcTransactionRepo
}

func (d *BitCoinDomain) Recharge(
	txId string,
	value float64,
	address string,
	time int64,
	blockhash string) error {
	bitCoinTransaction, err := d.btcTransactionRepo.FindByTxId(txId)
	if err != nil {
		return err
	}
	if bitCoinTransaction == nil {
		bt := &model.BitCoinTransaction{}
		bt.Type = model.RECHARGE
		bt.Time = time
		bt.BlockHash = blockhash
		bt.Value = value
		bt.TxId = txId
		bt.Address = address
		err := d.btcTransactionRepo.Save(bt)
		if err != nil {
			return err
		}
	}
	return nil
}

func NewBitCoinDomain(cli *database.MongoClient) *BitCoinDomain {
	return &BitCoinDomain{
		btcTransactionRepo: dao.NewBtcTransactionDao(cli.Db),
	}
}

~~~

~~~go
package repo

import "github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/model"

type BtcTransactionRepo interface {
	FindByTxId(txId string) (*model.BitCoinTransaction, error)
	Save(bt *model.BitCoinTransaction) error
}

~~~

~~~go
package dao

import (
	"context"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"github.com/LCY2013/blockchain/exchange/ff-coin/jobcenter/internal/model"
)

type BtcTransactionDao struct {
	db *mongo.Database
}

func (b *BtcTransactionDao) FindByTxId(txId string) (bt *model.BitCoinTransaction, err error) {
	collection := b.db.Collection("bitcoin_transaction")
	err = collection.FindOne(
		context.Background(),
		bson.D{{"txId", txId}}).Decode(&bt)
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	return
}

func (b *BtcTransactionDao) Save(bt *model.BitCoinTransaction) error {
	collection := b.db.Collection("bitcoin_transaction")
	_, err := collection.InsertOne(
		context.Background(),
		&bt)
	return err
}

func NewBtcTransactionDao(db *mongo.Database) *BtcTransactionDao {
	return &BtcTransactionDao{
		db: db,
	}
}

~~~

~~~go
package model

type BitCoinTransaction struct {
	TxId      string  `bson:"txId"`
	Time      int64   `bson:"time"`
	Value     float64 `bson:"value"`
	BlockHash string  `bson:"blockhash"`
	Address   string  `bson:"address"`
	Type      string  `bson:"type"` // RECHARGE 充值 WITHDRAW 提现
}

const RECHARGE = "RECHARGE"
const WITHDRAW = "WITHDRAW"

func (*BitCoinTransaction) Table() string {
	return "bitcoin_transaction"
}

~~~



~~~go

func PostWithHeader(path string, params any, headers map[string]string, proxy string) ([]byte, error) {
	ctx, cancelFunc := context.WithTimeout(context.Background(), 20*time.Second)
	defer cancelFunc()
	marshal, _ := json.Marshal(params)
	s := string(marshal)
	reqBody := strings.NewReader(s)
	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, path, reqBody)
	if err != nil {
		return nil, err
	}
	if headers != nil {
		for k, v := range headers {
			httpReq.Header.Set(k, v)
		}
	}
	client := http.DefaultClient
	if proxy != "" {
		proxyAddress, _ := url.Parse(proxy)
		client = &http.Client{
			Transport: &http.Transport{
				Proxy: http.ProxyURL(proxyAddress),
			},
		}
	}
	httpRsp, err := client.Do(httpReq)
	if err != nil {
		return nil, err
	}
	defer httpRsp.Body.Close()
	rspBody, err := io.ReadAll(httpRsp.Body)
	if err != nil {
		return nil, err
	}
	return rspBody, nil
}
~~~



#### 6.2.1 kafka发送

~~~go

func (d *QueueDomain) SendRecharge(value float64, address string, time int64) {
	data := make(map[string]any)
	data["value"] = value
	data["address"] = address
	data["time"] = time
	data["type"] = model.RECHARGE
	data["symbol"] = "BTC"
	marshal, _ := json.Marshal(data)
	msg := database.KafkaData{
		Topic: BtcTransactionTopic,
		Data:  marshal,
		Key:   []byte(address),
	}
	d.kafkaCli.Send(msg)
}
~~~



#### 6.2.2 kafka接收

~~~go
package consumer

import (
	"encoding/json"
	"github.com/zeromicro/go-zero/core/stores/redis"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"time"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ucenter/internal/database"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ucenter/internal/domain"
)

type BitCoinTransactionResult struct {
	Value   float64 `json:"value"`
	Time    int64   `json:"time"`
	Address string  `json:"address"`
	Type    string  `json:"type"`
	Symbol  string  `json:"symbol"`
}

func BitCoinTransaction(redisCli *redis.Redis, kafkaCli *database.KafkaClient, db *msdb.MsDB) {
	for {
		kafkaData := kafkaCli.Read()
		var bt BitCoinTransactionResult
		json.Unmarshal(kafkaData.Data, &bt)
		//解析出来数据 调用domain存储到数据库即可
		transactionDomain := domain.NewMemberTransactionDomain(db)
		err := transactionDomain.SaveRecharge(bt.Address, bt.Value, bt.Time, bt.Type, bt.Symbol)
		if err != nil {
			time.Sleep(200 * time.Millisecond)
			kafkaCli.Rput(kafkaData)
		}
	}
}

~~~



~~~go

func (d *MemberTransactionDomain) SaveRecharge(address string, value float64, time int64, t string, symbol string) error {
	time = time * 1000
	ctx := context.Background()
	memberTransaction, err := d.memberTransactionRepo.FindByAmountAndTime(ctx, address, value, time)
	if err != nil {
		return err
	}
	wallet, err := d.memberWalletDomain.FindByAddress(ctx, address)
	if err != nil {
		return err
	}
	if wallet == nil {
		return errors.New("address not exist ")
	}
	if memberTransaction == nil {
		transactionType := model.TypeMap.Code(t)
		memberTransaction = &model.MemberTransaction{}
		memberTransaction.MemberId = wallet.MemberId
		memberTransaction.Address = address
		memberTransaction.Type = transactionType
		memberTransaction.CreateTime = time * 1000
		memberTransaction.Amount = value
		memberTransaction.Symbol = symbol
		err := d.memberTransactionRepo.Save(ctx, memberTransaction)
		if err != nil {
			return err
		}
	}
	return nil
}
~~~

~~~go
func (d *MemberTransactionDao) FindByAmountAndTime(ctx context.Context, amount float64, address string, time int64) (mt *model.MemberTransaction, err error) {
	session := d.conn.Session(ctx)
	db := session.Model(&model.MemberTransaction{}).Where("amount=? and address=? and create_time=?", amount, address, time)
	err = db.Take(&mt).Error
	if err == gorm.ErrRecordNotFound {
		return nil, nil
	}
	return
}
~~~

~~~go
func (d *MemberWalletDomain) FindByAddress(address string) (*model.MemberWallet, error) {
	return d.memberWalletRepo.FindByAddress(context.Background(), address)
}
~~~

~~~go
func (m *MemberWalletDao) FindByAddress(ctx context.Context, address string) (mw *model.MemberWallet, err error) {
	session := m.conn.Session(ctx)
	err = session.Model(&model.MemberWallet{}).
		Where("address=?", address).Take(&mw).Error
	if err == gorm.ErrRecordNotFound {
		return nil, nil
	}
	return
}
~~~

