# 币币交易-2

## 1. 获取用户钱包信息

要做交易，比如买入还是卖出，需要确定用户当前到底有没有这么多钱，所以我们需要先获取用户的钱包信息。

### 1.1 sql

~~~sql
CREATE TABLE `member_wallet`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `address` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '充值地址',
  `balance` decimal(18, 8) NOT NULL COMMENT '可用余额',
  `frozen_balance` decimal(18, 8) NOT NULL COMMENT '冻结余额',
  `release_balance` decimal(18, 8) NOT NULL COMMENT '待释放余额',
  `is_lock` int(0) NOT NULL DEFAULT 0 COMMENT '钱包不是锁定 0 否 1 是',
  `member_id` bigint(0) NOT NULL COMMENT '用户id',
  `version` int(0) NOT NULL COMMENT '版本',
  `coin_id` bigint(0) NOT NULL COMMENT '货币id',
  `to_released` decimal(18, 8) NOT NULL COMMENT '待释放总量',
  `coin_name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '货币名称',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `UKm68bscpof0bpnxocxl4qdnvbe`(`member_id`, `coin_id`) USING BTREE,
  INDEX `FKf9tgbp9y9py8t9c5xj0lllcib`(`coin_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = DYNAMIC;
~~~



对应模型：

~~~go
type MemberWallet struct {
    Id  int64  `gorm:"column:id"`
    Address  string  `gorm:"column:address"`
    Balance  float64  `gorm:"column:balance"`
    FrozenBalance  float64  `gorm:"column:frozen_balance"`
    ReleaseBalance  float64  `gorm:"column:release_balance"`
    IsLock  int  `gorm:"column:is_lock"`
    MemberId  int64  `gorm:"column:member_id"`
    Version  int  `gorm:"column:version"`
    CoinId  int64  `gorm:"column:coin_id"`
    ToReleased  float64  `gorm:"column:to_released"`
    CoinName  string  `gorm:"column:coin_name"`
}
~~~

### 1.2 认证中间件

~~~go
package midd

import (
	"context"
	"github.com/zeromicro/go-zero/rest/httpx"
	common "github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/tools"
	"net/http"
)

func Auth(secret string) func(next http.HandlerFunc) http.HandlerFunc {
	return func(next http.HandlerFunc) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			result := common.NewResult()
			result.Fail(4000, "no login")
			token := r.Header.Get("x-auth-token")
			if token == "" {
				httpx.WriteJson(w, 200, result)
				return
			}
			userId, err := tools.ParseToken(token, secret)
			if err != nil {
				httpx.WriteJson(w, 200, result)
				return
			}
			ctx := r.Context()
			ctx = context.WithValue(ctx, "userId", userId)
			r = r.WithContext(ctx)
			next(w, r)
		}
	}
}

~~~

### 1.3 实现

~~~go
assetGroup := r.Group()
	assetGroup.Use(midd.Auth(serverCtx.Config.JWT.AccessSecret))
	assetGroup.Post("/uc/asset/wallet/:coinName", asset.FindWalletBySymbol)
~~~

参数：

~~~go
type AssetReq struct {
	CoinName     string      `json:"coinName,optional" path:"coinName,optional"`
	Ip string `json:"ip,optional"`
}
~~~

响应：

~~~go

type Coin struct {
	Id  int  `json:"id" from:"id"`
	Name  string  `json:"name" from:"name"`
	CanAutoWithdraw  int  `json:"canAutoWithdraw" from:"canAutoWithdraw"`
	CanRecharge  int  `json:"canRecharge" from:"canRecharge"`
	CanTransfer  int  `json:"canTransfer" from:"canTransfer"`
	CanWithdraw  int  `json:"canWithdraw" from:"canWithdraw"`
	CnyRate  float64  `json:"cnyRate" from:"cnyRate"`
	EnableRpc  int  `json:"enableRpc" from:"enableRpc"`
	IsPlatformCoin  int  `json:"isPlatformCoin" from:"isPlatformCoin"`
	MaxTxFee  float64  `json:"maxTxFee" from:"maxTxFee"`
	MaxWithdrawAmount  float64  `json:"maxWithdrawAmount" from:"maxWithdrawAmount"`
	MinTxFee  float64  `json:"minTxFee" from:"minTxFee"`
	MinWithdrawAmount  float64  `json:"minWithdrawAmount" from:"minWithdrawAmount"`
	NameCn  string  `json:"nameCn" from:"nameCn"`
	Sort  int  `json:"sort" from:"sort"`
	Status  int  `json:"status" from:"status"`
	Unit  string  `json:"unit" from:"unit"`
	UsdRate  float64  `json:"usdRate" from:"usdRate"`
	WithdrawThreshold  float64  `json:"withdrawThreshold" from:"withdrawThreshold"`
	HasLegal  int  `json:"hasLegal" from:"hasLegal"`
	ColdWalletAddress  string  `json:"coldWalletAddress" from:"coldWalletAddress"`
	MinerFee  float64  `json:"minerFee" from:"minerFee"`
	WithdrawScale  int  `json:"withdrawScale" from:"withdrawScale"`
	AccountType  int  `json:"accountType" from:"accountType"`
	DepositAddress  string  `json:"depositAddress" from:"depositAddress"`
	Infolink  string  `json:"infolink" from:"infolink"`
	Information  string  `json:"information" from:"information"`
	MinRechargeAmount  float64  `json:"minRechargeAmount" from:"minRechargeAmount"`
}

type MemberWallet struct {
	Id  int64  `json:"id" from:"id"`
	Address  string  `json:"address" from:"address"`
	Balance  float64  `json:"balance" from:"balance"`
	FrozenBalance  float64  `json:"frozenBalance" from:"frozenBalance"`
	ReleaseBalance  float64  `json:"releaseBalance" from:"releaseBalance"`
	IsLock  int  `json:"isLock" from:"isLock"`
	MemberId  int64  `json:"memberId" from:"memberId"`
	Version  int  `json:"version" from:"version"`
	Coin  Coin  `json:"coin" from:"coinId"`
	ToReleased  float64  `json:"toReleased" from:"toReleased"`
}
~~~

~~~go
func (h *AssetHandler) FindWalletBySymbol(w http.ResponseWriter, r *http.Request) {
	var req types.AssetReq
	if err := httpx.ParsePath(r, &req); err != nil {
		httpx.ErrorCtx(r.Context(), w, err)
		return
	}
	ip := tools.GetRemoteClientIp(r)
	req.Ip = ip
	l := logic.NewAssetLogic(r.Context(), h.svcCtx)
	resp, err := l.FindWalletBySymbol(&req)
	result := common.NewResult().Deal(resp, err)
	httpx.OkJsonCtx(r.Context(), w, result)
}
~~~

~~~gp
package logic

import (
	"context"
	"github.com/jinzhu/copier"
	"ffcoin/grpc-common/ucenter/asset"
	"time"
	"ucenterapi/internal/svc"
	"ucenterapi/internal/types"

	"github.com/zeromicro/go-zero/core/logx"
)

type Asset struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

func NewAssetLogic(ctx context.Context, svcCtx *svc.ServiceContext) *Asset {
	return &Asset{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *Asset) FindWalletBySymbol(req *types.AssetReq) (*types.MemberWallet, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	value := l.ctx.Value("userId").(int64)
	memberWallet, err := l.svcCtx.UAssetRpc.FindWalletBySymbol(ctx, &asset.AssetReq{
		CoinName: req.CoinName,
		UserId:   value,
	})
	if err != nil {
		return nil, err
	}
	resp := &types.MemberWallet{}
	if err := copier.Copy(resp, memberWallet); err != nil {
		return nil, err
	}
	return resp, nil
}

~~~

rpc：

~~~protobuf
syntax = "proto3";

package asset;

// protoc-gen-go 版本大于1.4.0, proto文件需要加上go_package,否则无法生成
option go_package = "./asset";

message AssetReq {
  string coinName = 1;
  string ip = 2;
  int64 userId = 3;
}


message Coin{
  int32 id  = 1;
  string name  = 2;
  int32 canAutoWithdraw  = 3;
  int32 canRecharge  = 4;
  int32 canTransfer  = 5;
  int32 canWithdraw  = 6;
  double cnyRate  = 7;
  int32 enableRpc  = 8;
  int32 isPlatformCoin  = 9;
  double maxTxFee  = 10;
  double maxWithdrawAmount  = 11;
  double minTxFee  = 12;
  double minWithdrawAmount  = 13;
  string nameCn  = 14;
  int32 sort  = 15;
  int32 status  = 16;
  string unit  = 17;
  double usdRate  = 18;
  double withdrawThreshold  = 19;
  int32 hasLegal  = 20;
  string coldWalletAddress  = 21;
  double minerFee  = 22;
  int32 withdrawScale  = 23;
  int32 accountType  = 24;
  string depositAddress  = 25;
  string infolink  = 26;
  string information  = 27;
  double minRechargeAmount  = 28;
}

message MemberWallet{
  int64 id  = 1;
  string address  = 2;
  double balance  = 3;
  double frozenBalance  = 4;
  double releaseBalance  = 5;
  int32 isLock  = 6;
  int64 memberId  = 7;
  int32 version  = 8;
  Coin coin  = 9;
  double toReleased  = 10;
}

service Asset {
  rpc findWalletBySymbol(AssetReq) returns(MemberWallet);
}
~~~

~~~GO
package svc

import (
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/zrpc"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"ffcoin/grpc-common/market/mclient"
	"ffcoin/ucenter/internal/config"
	"ffcoin/ucenter/internal/database"
)

type ServiceContext struct {
	Config    config.Config
	Cache     cache.Cache
	Db        *msdb.MsDB
	MarketRpc mclient.Market
}

func NewServiceContext(c config.Config) *ServiceContext {
	newRedis := c.CacheRedis[0].NewRedis()
	node := cache.NewNode(newRedis, nil, cache.NewStat("ucenter"), nil)
	db := database.ConnMysql(c.Mysql.DataSource)
	return &ServiceContext{
		Config:    c,
		Cache:     node,
		Db:        db,
		MarketRpc: mclient.NewMarket(zrpc.MustNewClient(c.MarketRpc)),
	}
}

~~~

~~~YAML
MarketRpc:
  Etcd:
    Hosts:
      - 127.0.0.1:2379
    Key: market.rpc
~~~

~~~go
package logic

import (
	"context"
	"github.com/jinzhu/copier"
	"github.com/zeromicro/go-zero/core/logx"
	"ffcoin/grpc-common/market/market"
	"ffcoin/grpc-common/ucenter/asset"
	"ffcoin/ucenter/internal/domain"
	"ffcoin/ucenter/internal/svc"
)

type AssetLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
	memberDomain       *domain.MemberDomain
	memberWalletDomain *domain.MemberWalletDomain
}

func (l *AssetLogic) FindWalletBySymbol(req *asset.AssetReq) (*asset.MemberWallet, error) {
	ctx := context.Background()
	coinInfo, err := l.svcCtx.MarketRpc.FindCoinInfo(ctx, &market.MarketReq{
		Unit: req.CoinName,
	})
	if err != nil {
		return nil, err
	}
	memberWalletCoin, err := l.memberWalletDomain.FindWalletBySymbol(ctx, req.UserId, req.CoinName, coinInfo)
	if err != nil {
		return nil, err
	}
	resp := &asset.MemberWallet{}
	copier.Copy(resp, memberWalletCoin)
	return resp, nil
}

func NewAssetLogic(ctx context.Context, svcCtx *svc.ServiceContext) *AssetLogic {
	return &AssetLogic{
		ctx:                ctx,
		svcCtx:             svcCtx,
		Logger:             logx.WithContext(ctx),
		memberDomain:       domain.NewMemberDomain(svcCtx.Db),
		memberWalletDomain: domain.NewMemberWalletDomain(svcCtx.Db),
	}
}

~~~

~~~go
package repo

import (
	"context"
	"ffcoin/ucenter/internal/model"
)

type MemberWalletRepo interface {
	Save(ctx context.Context, mw *model.MemberWallet) error
	FindByIdAndCoinName(ctx context.Context, memId int64, coinName string) (mw *model.MemberWallet, err error)
}

~~~

~~~go
package dao

import (
	"context"
	"gorm.io/gorm"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb/gorms"
	"ffcoin/ucenter/internal/model"
)

type MemberWalletDao struct {
	conn *gorms.GormConn
}

func (m *MemberWalletDao) Save(ctx context.Context, mw *model.MemberWallet) error {
	session := m.conn.Session(ctx)
	err := session.Save(&mw).Error
	return err
}

func (m *MemberWalletDao) FindByIdAndCoinName(ctx context.Context, memId int64, coinName string) (mw *model.MemberWallet, err error) {
	session := m.conn.Session(ctx)
	err = session.Model(&model.MemberWallet{}).
		Where("member_id=? and coin_name=?", memId, coinName).
		Take(&mw).Error
	if err == gorm.ErrRecordNotFound {
		return nil, nil
	}
	return
}

func NewMemberWalletDao(db *msdb.MsDB) *MemberWalletDao {
	return &MemberWalletDao{
		conn: gorms.New(db.DB),
	}
}

~~~

~~~go
package domain

import (
	"context"
	"github.com/jinzhu/copier"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"ffcoin/grpc-common/market/mclient"
	"ffcoin/ucenter/internal/dao"
	"ffcoin/ucenter/internal/model"
	"ffcoin/ucenter/internal/repo"
)

type MemberWalletDomain struct {
	memberWalletRepo repo.MemberWalletRepo
}

func (d *MemberWalletDomain) FindWalletBySymbol(ctx context.Context, id int64, name string, coin *mclient.Coin) (*model.MemberWalletCoin, error) {
	mw, err := d.memberWalletRepo.FindByIdAndCoinName(ctx, id, name)
	if err != nil {
		return nil, err
	}
	if mw == nil {
		//新建并存储
		mw, walletCoin := model.NewMemberWallet(id, coin)
		err := d.memberWalletRepo.Save(ctx, mw)
		if err != nil {
			return nil, err
		}
		return walletCoin, nil
	}
	nwc := &model.MemberWalletCoin{}
	copier.Copy(nwc, mw)
	nwc.Coin = coin
	return nwc, nil
}

func NewMemberWalletDomain(db *msdb.MsDB) *MemberWalletDomain {
	return &MemberWalletDomain{
		dao.NewMemberWalletDao(db),
	}
}

~~~

~~~go
package model

import "ffcoin/grpc-common/market/market"

type MemberWallet struct {
	Id             int64   `gorm:"column:id"`
	Address        string  `gorm:"column:address"`
	Balance        float64 `gorm:"column:balance"`
	FrozenBalance  float64 `gorm:"column:frozen_balance"`
	ReleaseBalance float64 `gorm:"column:release_balance"`
	IsLock         int     `gorm:"column:is_lock"`
	MemberId       int64   `gorm:"column:member_id"`
	Version        int     `gorm:"column:version"`
	CoinId         int64   `gorm:"column:coin_id"`
	ToReleased     float64 `gorm:"column:to_released"`
	CoinName       string  `gorm:"column:coin_name"`
}

func (*MemberWallet) TableName() string {
	return "member_wallet"
}

//type Coin struct {
//	Id                int     `json:"id" from:"id"`
//	Name              string  `json:"name" from:"name"`
//	CanAutoWithdraw   int     `json:"canAutoWithdraw" from:"canAutoWithdraw"`
//	CanRecharge       int     `json:"canRecharge" from:"canRecharge"`
//	CanTransfer       int     `json:"canTransfer" from:"canTransfer"`
//	CanWithdraw       int     `json:"canWithdraw" from:"canWithdraw"`
//	CnyRate           float64 `json:"cnyRate" from:"cnyRate"`
//	EnableRpc         int     `json:"enableRpc" from:"enableRpc"`
//	IsPlatformCoin    int     `json:"isPlatformCoin" from:"isPlatformCoin"`
//	MaxTxFee          float64 `json:"maxTxFee" from:"maxTxFee"`
//	MaxWithdrawAmount float64 `json:"maxWithdrawAmount" from:"maxWithdrawAmount"`
//	MinTxFee          float64 `json:"minTxFee" from:"minTxFee"`
//	MinWithdrawAmount float64 `json:"minWithdrawAmount" from:"minWithdrawAmount"`
//	NameCn            string  `json:"nameCn" from:"nameCn"`
//	Sort              int     `json:"sort" from:"sort"`
//	Status            int     `json:"status" from:"status"`
//	Unit              string  `json:"unit" from:"unit"`
//	UsdRate           float64 `json:"usdRate" from:"usdRate"`
//	WithdrawThreshold float64 `json:"withdrawThreshold" from:"withdrawThreshold"`
//	HasLegal          int     `json:"hasLegal" from:"hasLegal"`
//	ColdWalletAddress string  `json:"coldWalletAddress" from:"coldWalletAddress"`
//	MinerFee          float64 `json:"minerFee" from:"minerFee"`
//	WithdrawScale     int     `json:"withdrawScale" from:"withdrawScale"`
//	AccountType       int     `json:"accountType" from:"accountType"`
//	DepositAddress    string  `json:"depositAddress" from:"depositAddress"`
//	Infolink          string  `json:"infolink" from:"infolink"`
//	Information       string  `json:"information" from:"information"`
//	MinRechargeAmount float64 `json:"minRechargeAmount" from:"minRechargeAmount"`
//}

type MemberWalletCoin struct {
	Id             int64        `json:"id" from:"id"`
	Address        string       `json:"address" from:"address"`
	Balance        float64      `json:"balance" from:"balance"`
	FrozenBalance  float64      `json:"frozenBalance" from:"frozenBalance"`
	ReleaseBalance float64      `json:"releaseBalance" from:"releaseBalance"`
	IsLock         int          `json:"isLock" from:"isLock"`
	MemberId       int64        `json:"memberId" from:"memberId"`
	Version        int          `json:"version" from:"version"`
	Coin           *market.Coin `json:"coin" from:"coinId"`
	ToReleased     float64      `json:"toReleased" from:"toReleased"`
}

func NewMemberWallet(memId int64, coin *market.Coin) (*MemberWallet, *MemberWalletCoin) {
	mw := &MemberWallet{
		MemberId: memId,
		CoinId:   int64(coin.Id),
		CoinName: coin.Unit,
	}
	mwc := &MemberWalletCoin{
		MemberId: memId,
		Coin:     coin,
	}
	return mw, mwc
}

~~~

## 2. 历史委托订单

### 2.1 sql

~~~sql
CREATE TABLE `exchange_order`  (
  `id` bigint(0) NOT NULL AUTO_INCREMENT,
  `order_id` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '订单id',
  `amount` decimal(18, 8) NOT NULL DEFAULT 0.00000000 COMMENT '买入或者卖出量',
  `base_symbol` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '结算单位',
  `canceled_time` bigint(0) NOT NULL COMMENT '取消时间',
  `coin_symbol` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '币单位',
  `completed_time` bigint(0) NOT NULL COMMENT '完成时间',
  `direction` int(0) NOT NULL COMMENT '订单方向 0 买 1 卖',
  `member_id` bigint(0) NOT NULL,
  `price` decimal(18, 8) NOT NULL DEFAULT 0.00000000 COMMENT '挂单价格',
  `status` int(0) NOT NULL COMMENT '订单状态 0 交易中 1 完成 2 取消 3 超时',
  `symbol` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '交易对',
  `time` bigint(0) NOT NULL COMMENT '挂单时间',
  `traded_amount` decimal(18, 8) NOT NULL DEFAULT 0.00000000 COMMENT '成交量',
  `turnover` decimal(18, 8) NOT NULL DEFAULT 0.00000000 COMMENT '成交额 ',
  `type` int(0) NOT NULL COMMENT '挂单类型 0 市场价 1 最低价',
  `use_discount` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT '是否使用折扣 0 不使用 1使用',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `order_id`(`order_id`) USING BTREE,
  INDEX `index_member_id_time`(`member_id`, `time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 84 CHARACTER SET = utf8mb3 COLLATE = utf8mb3_general_ci ROW_FORMAT = DYNAMIC;
~~~

~~~go
package model

import "github.com/jinzhu/copier"

type ExchangeOrder struct {
	Id            int64   `gorm:"column:id"`
	OrderId       string  `gorm:"column:order_id"`
	Amount        float64 `gorm:"column:amount"`
	BaseSymbol    string  `gorm:"column:base_symbol"`
	CanceledTime  int64   `gorm:"column:canceled_time"`
	CoinSymbol    string  `gorm:"column:coin_symbol"`
	CompletedTime int64   `gorm:"column:completed_time"`
	Direction     int     `gorm:"column:direction"`
	MemberId      int64   `gorm:"column:member_id"`
	Price         float64 `gorm:"column:price"`
	Status        int     `gorm:"column:status"`
	Symbol        string  `gorm:"column:symbol"`
	Time          int64   `gorm:"column:time"`
	TradedAmount  float64 `gorm:"column:traded_amount"`
	Turnover      float64 `gorm:"column:turnover"`
	Type          int     `gorm:"column:type"`
	UseDiscount   string  `gorm:"column:use_discount"`
}

func (*ExchangeOrder) TableName() string {
	return "exchange_order"
}

// status
const (
	Trading = iota
	Completed
	Canceled
	OverTimed
)

var statusMap = map[int]string{
	Trading:   "TRADING",
	Completed: "COMPLETED",
	Canceled:  "CANCELED",
	OverTimed: "OVERTIMED",
}

// direction
const (
	BUY = iota
	SELL
)

var directionMap = map[int]string{
	BUY:  "BUY",
	SELL: "SELL",
}

// type
const (
	MarketPrice = iota
	LimitPrice
)

var typeMap = map[int]string{
	MarketPrice: "MARKET_PRICE",
	LimitPrice:  "LIMIT_PRICE",
}

type ExchangeOrderVo struct {
	OrderId       string  `gorm:"column:order_id"`
	Amount        float64 `gorm:"column:amount"`
	BaseSymbol    string  `gorm:"column:base_symbol"`
	CanceledTime  int64   `gorm:"column:canceled_time"`
	CoinSymbol    string  `gorm:"column:coin_symbol"`
	CompletedTime int64   `gorm:"column:completed_time"`
	Direction     string  `gorm:"column:direction"`
	MemberId      int64   `gorm:"column:member_id"`
	Price         float64 `gorm:"column:price"`
	Status        string  `gorm:"column:status"`
	Symbol        string  `gorm:"column:symbol"`
	Time          int64   `gorm:"column:time"`
	TradedAmount  float64 `gorm:"column:traded_amount"`
	Turnover      float64 `gorm:"column:turnover"`
	Type          string  `gorm:"column:type"`
	UseDiscount   string  `gorm:"column:use_discount"`
}

func (old *ExchangeOrder) ToVo() *ExchangeOrderVo {
	eo := &ExchangeOrderVo{}
	copier.Copy(eo, old)
	eo.Status = statusMap[old.Status]
	eo.Direction = directionMap[old.Direction]
	eo.Type = typeMap[old.Type]
	return eo
}

~~~



### 2.2 nginx



~~~go
location /exchange {
        client_max_body_size    5m;
        proxy_pass http://localhost:8890;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
~~~

nginx -s reload

### 2.3 api

~~~go
func RegisterHandlers(r *Routers, serverCtx *svc.ServiceContext) {
	order := NewOrderHandler(serverCtx)
	orderGroup := r.Group()
	orderGroup.Use(midd.Auth(serverCtx.Config.JWT.AccessSecret))
	orderGroup.Post("/order/history", order.History)
}

~~~

~~~go
package handler

import (
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange-api/internal/logic"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange-api/internal/svc"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange-api/internal/types"
	"github.com/zeromicro/go-zero/rest/httpx"
	common "github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/tools"
	"net/http"
)

type OrderHandler struct {
	svcCtx *svc.ServiceContext
}

func (h *OrderHandler) History(w http.ResponseWriter, r *http.Request) {
	var req types.ExchangeReq
	if err := httpx.ParseForm(r, &req); err != nil {
		httpx.ErrorCtx(r.Context(), w, err)
		return
	}
	ip := tools.GetRemoteClientIp(r)
	req.Ip = ip
	l := logic.NewOrderLogic(r.Context(), h.svcCtx)
	resp, err := l.History(&req)
	result := common.NewResult().Deal(resp, err)
	httpx.OkJsonCtx(r.Context(), w, result)
}

func NewOrderHandler(svcCtx *svc.ServiceContext) *OrderHandler {
	return &OrderHandler{svcCtx}
}

~~~

~~~go
// Code generated by goctl. DO NOT EDIT.
package types


type ExchangeReq struct {
	Ip string `json:"ip,optional" form:"ip,optional"`
	Symbol string `json:"symbol,optional" form:"symbol,optional"`
	PageNo int64 `json:"pageNo,optional" form:"pageNo,optional"`
	PageSize int64 `json:"pageSize,optional" form:"pageSize,optional"`
}


type ExchangeOrder struct {
	Id  int64  `json:"id" from:"id"`
	OrderId  string  `json:"orderId" from:"orderId"`
	Amount  float64  `json:"amount" from:"amount"`
	BaseSymbol  string  `json:"baseSymbol" from:"baseSymbol"`
	CanceledTime  int64  `json:"canceledTime" from:"canceledTime"`
	CoinSymbol  string  `json:"coinSymbol" from:"coinSymbol"`
	CompletedTime  int64  `json:"completedTime" from:"completedTime"`
	Direction  int  `json:"direction" from:"direction"`
	MemberId  int64  `json:"memberId" from:"memberId"`
	Price  string  `json:"price" from:"price"`
	Status  string  `json:"status" from:"status"`
	Symbol  string  `json:"symbol" from:"symbol"`
	Time  int64  `json:"time" from:"time"`
	TradedAmount  float64  `json:"tradedAmount" from:"tradedAmount"`
	Turnover  float64  `json:"turnover" from:"turnover"`
	Type  string  `json:"type" from:"type"`
	UseDiscount  string  `json:"useDiscount" from:"useDiscount"`
}


~~~

~~~go
package logic

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange-api/internal/svc"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange-api/internal/types"
	"github.com/zeromicro/go-zero/core/logx"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/pages"
	"ffcoin/grpc-common/exchange/order"
)

type Order struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

func NewOrderLogic(ctx context.Context, svcCtx *svc.ServiceContext) *Order {
	return &Order{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *Order) History(req *types.ExchangeReq) (*pages.PageResult, error) {
	value := l.ctx.Value("userId").(int64)
	history, err := l.svcCtx.OrderRpc.FindOrderHistory(l.ctx, &order.OrderReq{
		Symbol:   req.Symbol,
		Page:     req.PageNo,
		PageSize: req.PageSize,
		UserId:   value,
	})
	if err != nil {
		return nil, err
	}
	list := history.List
	b := make([]any, len(list))
	for i := range list {
		b[i] = list[i]
	}
	return pages.New(b, req.PageNo, req.PageSize, history.Total), nil
}

~~~

~~~go
package pages

import "math"

type PageResult struct {
	Content       []any `json:"content"`       //内容
	TotalElements int64 `json:"totalElements"` //总数
	Number        int64 `json:"number"`        //当前页
	TotalPages    int64 `json:"totalPages"`    //总页数
	HasNext       bool  `json:"hasNext"`       //是否有下一页
	IsLast        bool  `json:"isLast"`        //是否最后
}

func New(content []any, page, pageSize, total int64) *PageResult {
	pr := &PageResult{}
	pr.Content = content
	pr.Number = page
	pr.TotalElements = total
	if pageSize <= 0 {
		pr.TotalPages = 1
	} else {
		pr.TotalPages = int64(math.Ceil(float64(total) / float64(pageSize)))
	}
	pr.HasNext = pr.Number+1 < pr.TotalPages
	pr.IsLast = !pr.HasNext
	return pr
}

~~~



### 2.4 rpc

~~~go
syntax = "proto3";

package order;

// protoc-gen-go 版本大于1.4.0, proto文件需要加上go_package,否则无法生成
option go_package = "./order";

message OrderReq {
  string ip = 1;
  string symbol = 2;
  int64 page = 4;
  int64 pageSize = 5;
  int64 userId = 6;
}

message OrderRes {
 repeated ExchangeOrder list = 1;
 int64 total = 2;
}


message ExchangeOrder{
  int64 id  = 1;
  string orderId  = 2;
  double amount  = 3;
  string baseSymbol  = 4;
  int64 canceledTime  = 5;
  string coinSymbol  = 6;
  int64 completedTime  = 7;
  string direction  = 8;
  int64 memberId  = 11;
  double price  = 12;
  string status  = 13;
  string symbol  = 14;
  int64 time  = 15;
  double tradedAmount  = 16;
  double turnover  = 17;
  string type  = 18;
  string useDiscount  = 21;
}

service Order {
  rpc FindOrderHistory(OrderReq) returns(OrderRes);
}
~~~

~~~go
package logic

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/domain"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/svc"
	"github.com/jinzhu/copier"
	"github.com/zeromicro/go-zero/core/logx"
	"ffcoin/grpc-common/exchange/order"
)

type ExchangeOrderLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
	orderDomain *domain.ExchangeOrderDomain
}

func NewExchangeOrderLogic(ctx context.Context, svcCtx *svc.ServiceContext) *ExchangeOrderLogic {
	return &ExchangeOrderLogic{
		ctx:         ctx,
		svcCtx:      svcCtx,
		Logger:      logx.WithContext(ctx),
		orderDomain: domain.NewExchangeOrderDomain(svcCtx.Db),
	}
}

func (l *ExchangeOrderLogic) FindOrderHistory(in *order.OrderReq) (*order.OrderRes, error) {
	exchangeOrders, total, err := l.orderDomain.FindBySymbolPage(
		l.ctx,
		in.Symbol,
		in.Page,
		in.PageSize,
		in.UserId)
	if err != nil {
		return nil, err
	}
	var list []*order.ExchangeOrder
	copier.Copy(&list, exchangeOrders)
	return &order.OrderRes{
		List:  list,
		Total: total,
	}, nil
}

~~~

~~~go
package domain

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/dao"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/model"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/repo"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
)

type ExchangeOrderDomain struct {
	exchangeOrderRepo repo.ExchangeOrderRepo
}

func (d *ExchangeOrderDomain) FindHistory(
	ctx context.Context,
	symbol string,
	page int64,
	pageSize int64,
	userId int64) ([]*model.ExchangeOrderVo, int64, error) {
	list, total, err := d.exchangeOrderRepo.FindBySymbolPage(
		ctx,
		symbol,
		userId,
		-1,
		int(page),
		int(pageSize),
		true)
	lv := make([]*model.ExchangeOrderVo, len(list))
	for i, v := range list {
		lv[i] = v.ToVo()
	}
	return lv, total, err
}

func NewExchangeOrderDomain(db *msdb.MsDB) *ExchangeOrderDomain {
	return &ExchangeOrderDomain{
		exchangeOrderRepo: dao.NewExchangeOrderDao(db),
	}
}

~~~

~~~go
package dao

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/model"
	"fmt"
	"gorm.io/gorm/clause"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb/gorms"
)

type ExchangeOrderDao struct {
	conn *gorms.GormConn
}

func (d *ExchangeOrderDao) FindBySymbolPage(
	ctx context.Context,
	symbol string,
	memId int64,
	status int,
	page int,
	pageSize int,
	isDesc bool) (list []*model.ExchangeOrder, total int64, err error) {
	session := d.conn.Session(ctx)
	index := (page - 1) * pageSize
	query := fmt.Sprintf("symbol = ?")
	params := []any{symbol}
	if memId != -1 {
		query += fmt.Sprintf(" and member_id = ?")
		params = append(params, memId)
	}
	if status != -1 {
		query += fmt.Sprintf(" and status = ?")
		params = append(params, status)
	}
	err = session.
		Model(&model.ExchangeOrder{}).
		Where(query, params...).
		Limit(pageSize).Offset(index).
		Order(clause.OrderByColumn{Column: clause.Column{Name: "time"}, Desc: isDesc}).
		Find(&list).Error
	err = session.
		Model(&model.ExchangeOrder{}).
		Where(query, params...).
		Count(&total).Error
	return
}

func NewExchangeOrderDao(db *msdb.MsDB) *ExchangeOrderDao {
	return &ExchangeOrderDao{
		conn: gorms.New(db.DB),
	}
}

~~~

~~~go
package repo

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/model"
)

type ExchangeOrderRepo interface {
	FindBySymbolPage(
		ctx context.Context,
		symbol string,
		memId int64,
		status int,
		page int,
		pageSize int,
		isDesc bool) (list []*model.ExchangeOrder, total int64, err error)
}

~~~

## 3. 当前委托订单

### 3.1 api

~~~go
orderGroup.Post("/order/current", order.Current)
~~~

~~~go

func (h *OrderHandler) Current(w http.ResponseWriter, r *http.Request) {
	var req types.ExchangeReq
	if err := httpx.ParseForm(r, &req); err != nil {
		httpx.ErrorCtx(r.Context(), w, err)
		return
	}
	ip := tools.GetRemoteClientIp(r)
	req.Ip = ip
	l := logic.NewOrderLogic(r.Context(), h.svcCtx)
	resp, err := l.Current(&req)
	result := common.NewResult().Deal(resp, err)
	httpx.OkJsonCtx(r.Context(), w, result)
}
~~~

~~~go

func (l *Order) Current(req *types.ExchangeReq) (*pages.PageResult, error) {
	value := l.ctx.Value("userId").(int64)
	history, err := l.svcCtx.OrderRpc.FindOrderCurrent(l.ctx, &order.OrderReq{
		Symbol:   req.Symbol,
		Page:     req.PageNo,
		PageSize: req.PageSize,
		UserId:   value,
	})
	if err != nil {
		return nil, err
	}
	list := history.List
	b := make([]any, len(list))
	for i := range list {
		b[i] = list[i]
	}
	return pages.New(b, req.PageNo, req.PageSize, history.Total), nil
}

~~~

### 3.2 rpc

~~~protobuf
syntax = "proto3";

package order;

// protoc-gen-go 版本大于1.4.0, proto文件需要加上go_package,否则无法生成
option go_package = "./order";

message OrderReq {
  string ip = 1;
  string symbol = 2;
  int64 page = 4;
  int64 pageSize = 5;
  int64 userId = 6;
}

message OrderRes {
 repeated ExchangeOrder list = 1;
 int64 total = 2;
}


message ExchangeOrder{
  int64 id  = 1;
  string orderId  = 2;
  double amount  = 3;
  string baseSymbol  = 4;
  int64 canceledTime  = 5;
  string coinSymbol  = 6;
  int64 completedTime  = 7;
  string direction  = 8;
  int64 memberId  = 11;
  double price  = 12;
  string status  = 13;
  string symbol  = 14;
  int64 time  = 15;
  double tradedAmount  = 16;
  double turnover  = 17;
  string type  = 18;
  string useDiscount  = 21;
}

service Order {
  rpc FindOrderHistory(OrderReq) returns(OrderRes);
  rpc FindOrderCurrent(OrderReq) returns(OrderRes);
}
~~~

~~~go

func (l *ExchangeOrderLogic) FindOrderCurrent(in *order.OrderReq) (*order.OrderRes, error) {
	exchangeOrders, total, err := l.orderDomain.FindTrading(
		l.ctx,
		in.Symbol,
		in.Page,
		in.PageSize,
		in.UserId)
	if err != nil {
		return nil, err
	}
	var list []*order.ExchangeOrder
	copier.Copy(&list, exchangeOrders)
	return &order.OrderRes{
		List:  list,
		Total: total,
	}, nil
}
~~~

~~~go


func (d *ExchangeOrderDomain) FindTrading(
	ctx context.Context,
	symbol string,
	page int64,
	pageSize int64,
	userId int64) ([]*model.ExchangeOrderVo, int64, error) {
	list, total, err := d.exchangeOrderRepo.FindBySymbolPage(
		ctx,
		symbol,
		userId,
		model.Trading,
		int(page),
		int(pageSize),
		true)
	lv := make([]*model.ExchangeOrderVo, len(list))
	for i, v := range list {
		lv[i] = v.ToVo()
	}
	return lv, total, err
}
~~~

## 4. 发布委托

发布委托逻辑其实就是创建订单，只不过这里有一个额外需要注意的地方，就是一旦发布委托，钱包中的钱就需要进行冻结，同时冻结的还有手续费。

逻辑：

* 判断参数是否合法
* 判断钱是否足够
* 创建订单，得到订单id和需要冻结的钱
* 发送消息到kafka
* ucenter接收消息，处理钱包冻结
* 失败则调用订单服务取消订单

### 4.1 api

~~~go
	orderGroup.Post("/order/add", order.Add)
~~~

参数：

~~~go
type ExchangeReq struct {
	Ip string `json:"ip,optional" form:"ip,optional"`
	Symbol string `json:"symbol,optional" form:"symbol,optional"`
	PageNo int64 `json:"pageNo,optional" form:"pageNo,optional"`
	PageSize int64 `json:"pageSize,optional" form:"pageSize,optional"`
	Price float64 `json:"price,optional" form:"price,optional"`
	Amount float64 `json:"amount,optional" form:"amount,optional"`
	Direction string `json:"direction,optional" form:"direction,optional"`
	Type string `json:"type,optional" form:"type,optional"`
	UseDiscount float64 `json:"useDiscount,optional" form:"useDiscount,optional"`
}
~~~

~~~go
func (r *ExchangeReq) OrderValid() bool {
	if r.Direction == "" || r.Type == "" {
		return false
	}
	return true
}

~~~

返回值：

~~~go
orderId
~~~

~~~go
func (h *OrderHandler) Add(w http.ResponseWriter, r *http.Request) {
	var req types.ExchangeReq
	if err := httpx.ParseForm(r, &req); err != nil {
		httpx.ErrorCtx(r.Context(), w, err)
		return
	}
	ip := tools.GetRemoteClientIp(r)
	req.Ip = ip
	l := logic.NewOrderLogic(r.Context(), h.svcCtx)
	resp, err := l.Add(&req)
	result := common.NewResult().Deal(resp, err)
	httpx.OkJsonCtx(r.Context(), w, result)
}

~~~

~~~go

func (l *Order) Add(req *types.ExchangeReq) (string, error) {
	value := l.ctx.Value("userId").(int64)
	if !req.OrderValid() {
		return "", errors.New("参数传递错误")
	}
	orderRes, err := l.svcCtx.OrderRpc.Add(l.ctx, &order.OrderReq{
		Symbol:    req.Symbol,
		UserId:    value,
		Direction: req.Direction,
		Type:      req.Type,
		Price:     req.Price,
		Amount:    req.Amount,
	})
	if err != nil {
		return "", err
	}
	return orderRes.OrderId, nil
}
~~~

### 4.2 rpc

~~~go
package enums

type Enum map[int]string

func (e Enum) Code(value string) (int, bool) {
	for k, v := range e {
		if v == value {
			return k, true
		}
	}
	return -1, false
}

func (e Enum) Value(code int) (string, bool) {
	value, ok := e[code]
	return value, ok
}

~~~



~~~protobuf
syntax = "proto3";

package order;

// protoc-gen-go 版本大于1.4.0, proto文件需要加上go_package,否则无法生成
option go_package = "./order";

message OrderReq {
  string ip = 1;
  string symbol = 2;
  int64 page = 4;
  int64 pageSize = 5;
  int64 userId = 6;
  double price = 7;
  double amount = 8;
  string direction = 9;
  string type = 10;
  int32 useDiscount = 11;
  string orderId = 12;
  int32 updateStatus = 13;
}

message OrderRes {
 repeated ExchangeOrder list = 1;
 int64 total = 2;
}


message ExchangeOrder{
  int64 id  = 1;
  string orderId  = 2;
  double amount  = 3;
  string baseSymbol  = 4;
  int64 canceledTime  = 5;
  string coinSymbol  = 6;
  int64 completedTime  = 7;
  string direction  = 8;
  int64 memberId  = 11;
  double price  = 12;
  string status  = 13;
  string symbol  = 14;
  int64 time  = 15;
  double tradedAmount  = 16;
  double turnover  = 17;
  string type  = 18;
  string useDiscount  = 21;
}

message AddOrderRes {
  string orderId = 1;
}
message CancelOrderRes {
  string orderId = 1;
}

message ExchangeOrderOrigin{
  int64 id  = 1;
  string orderId  = 2;
  double amount  = 3;
  string baseSymbol  = 4;
  int64 canceledTime  = 5;
  string coinSymbol  = 6;
  int64 completedTime  = 7;
  int32 direction  = 8;
  int64 memberId  = 11;
  double price  = 12;
  int32 status  = 13;
  string symbol  = 14;
  int64 time  = 15;
  double tradedAmount  = 16;
  double turnover  = 17;
  int32 type  = 18;
  string useDiscount  = 21;
}

service Order {
  rpc FindOrderHistory(OrderReq) returns(OrderRes);
  rpc FindOrderCurrent(OrderReq) returns(OrderRes);
  rpc Add(OrderReq) returns(AddOrderRes);
  rpc FindByOrderId(OrderReq) returns(ExchangeOrderOrigin);
  rpc CancelOrder(OrderReq) returns(CancelOrderRes);
}
~~~



~~~go

func (l *ExchangeOrderLogic) Add(req *order.OrderReq) (*order.AddOrderRes, error) {
	memberRes, err := l.svcCtx.MemberRpc.FindMemberById(l.ctx, &member.MemberReq{
		MemberId: req.UserId,
	})
	if err != nil {
		return nil, err
	}
	if memberRes.TransactionStatus == 0 {
		return nil, errors.New("此用户已经被禁止交易")
	}
	if req.Type == model.TypeMap[model.LimitPrice] && req.Price <= 0 {
		return nil, errors.New("限价模式下价格不能小于等于0")
	}
	if req.Amount <= 0 {
		return nil, errors.New("数量不能小于等于0")
	}
	exchangeCoin, err := l.svcCtx.MarketRpc.FindSymbolInfo(l.ctx, &market.MarketReq{
		Symbol: req.Symbol,
	})
	if err != nil {
		return nil, errors.New("nonsupport coin")
	}
	if exchangeCoin.Exchangeable != 1 && exchangeCoin.Enable != 1 {
		return nil, errors.New("coin forbidden")
	}
	//基准币
	baseSymbol := exchangeCoin.GetBaseSymbol()
	//交易币
	coinSymbol := exchangeCoin.GetCoinSymbol()
    cc := baseSymbol
	if req.Direction == model.DirectionMap[model.SELL] {
		//根据交易币查询
		cc = coinSymbol
	}
	coin, err := l.svcCtx.MarketRpc.FindCoinInfo(l.ctx, &market.MarketReq{
		Unit: cc,
	})
	if err != nil || coin == nil {
		return nil, errors.New("nonsupport coin")
	}
	if req.Type == model.TypeMap[model.MarketPrice] && req.Direction == model.DirectionMap[model.BUY] {
		if exchangeCoin.GetMinTurnover() > 0 && req.Amount < float64(exchangeCoin.GetMinTurnover()) {
			return nil, errors.New("成交额至少是" + fmt.Sprintf("%d", exchangeCoin.GetMinTurnover()))
		}
	} else {
		if exchangeCoin.GetMaxVolume() > 0 && exchangeCoin.GetMaxVolume() < req.Amount {
			return nil, errors.New("数量超出" + fmt.Sprintf("%f", exchangeCoin.GetMaxVolume()))
		}
		if exchangeCoin.GetMinVolume() > 0 && exchangeCoin.GetMinVolume() > req.Amount {
			return nil, errors.New("数量不能低于" + fmt.Sprintf("%f", exchangeCoin.GetMinVolume()))
		}
	}
	//查询用户钱包
	baseWallet, err := l.svcCtx.AssetRpc.FindWalletBySymbol(l.ctx, &asset.AssetReq{
		UserId:   req.UserId,
		CoinName: baseSymbol,
	})
	if err != nil {
		return nil, errors.New("no wallet")
	}
	exCoinWallet, err := l.svcCtx.AssetRpc.FindWalletBySymbol(l.ctx, &asset.AssetReq{
		UserId:   req.UserId,
		CoinName: coinSymbol,
	})
	if err != nil {
		return nil, errors.New("no wallet")
	}
	if baseWallet.IsLock == 1 || exCoinWallet.IsLock == 1 {
		return nil, errors.New("wallet locked")
	}
	if req.Direction == model.DirectionMap[model.SELL] && exchangeCoin.GetMinSellPrice() > 0 {
		if req.Price < exchangeCoin.GetMinSellPrice() || req.Type == model.TypeMap[model.MarketPrice] {
			return nil, errors.New("不能低于最低限价:" + fmt.Sprintf("%f", exchangeCoin.GetMinSellPrice()))
		}
	}
	if req.Direction == model.DirectionMap[model.BUY] && exchangeCoin.GetMaxBuyPrice() > 0 {
		if req.Price > exchangeCoin.GetMaxBuyPrice() || req.Type == model.TypeMap[model.MarketPrice] {
			return nil, errors.New("不能低于最高限价:" + fmt.Sprintf("%f", exchangeCoin.GetMaxBuyPrice()))
		}
	}
	//是否启用了市价买卖
	if req.Type == model.TypeMap[model.MarketPrice] {
		if req.Direction == model.DirectionMap[model.BUY] && exchangeCoin.EnableMarketBuy == 0 {
			return nil, errors.New("不支持市价购买")
		} else if req.Direction == model.DirectionMap[model.SELL] && exchangeCoin.EnableMarketSell == 0 {
			return nil, errors.New("不支持市价出售")
		}
	}
	//限制委托数量
	count, err := l.orderDomain.FindCurrentTradingCount(l.ctx, req.UserId, req.Symbol, req.Direction)
	if err != nil {
		return nil, err
	}
	if exchangeCoin.GetMaxTradingOrder() > 0 && count >= exchangeCoin.GetMaxTradingOrder() {
		return nil, errors.New("超过最大挂单数量 " + fmt.Sprintf("%d", exchangeCoin.GetMaxTradingOrder()))
	}
	//开始生成订单
	exchangeOrder := model.NewOrder()
	exchangeOrder.MemberId = req.UserId
	exchangeOrder.Symbol = req.Symbol
	exchangeOrder.BaseSymbol = baseSymbol
	exchangeOrder.CoinSymbol = coinSymbol
	typeCode, _ := model.TypeMap.Code(req.Type)
	exchangeOrder.Type = typeCode
	directionCode, _ := model.DirectionMap.Code(req.Direction)
	exchangeOrder.Direction = directionCode
	if exchangeOrder.Type == model.MarketPrice {
		exchangeOrder.Price = 0
	} else {
		exchangeOrder.Price = req.Price
	}
	exchangeOrder.UseDiscount = "0"
	exchangeOrder.Amount = req.Amount
	err = l.transaction.Action(func(conn msdb.DbConn) error {
		money, err := l.orderDomain.AddOrder(l.ctx, conn, exchangeOrder, exchangeCoin, baseWallet, exCoinWallet)
		if err != nil {
			return errors.New("订单提交失败")
		}
		//通过kafka发送订单消息，进行钱包货币扣除 同步发送 要保证发送成功
		ok := l.kafkaDomain.Send(
			"add-exchange-order",
			req.UserId,
			exchangeOrder.OrderId,
			money,
			req.Symbol,
			exchangeOrder.Direction,
			baseSymbol,
			coinSymbol)
		if !ok {
			return errors.New("消息队列出现故障，未能扣款")
		}
		logx.Info("发送成功，订单id:", exchangeOrder.OrderId)
		return nil
	})
	if err != nil {
		return nil, err
	}
	return &order.AddOrderRes{
		OrderId: exchangeOrder.OrderId,
	}, nil
}

func (l *ExchangeOrderLogic) FindByOrderId(req *order.OrderReq) (*order.ExchangeOrderOrigin, error) {
	orderId := req.OrderId
	exOrder, err := l.orderDomain.FindByOrderId(l.ctx, orderId)
	if err != nil {
		return nil, err
	}
	res := &order.ExchangeOrderOrigin{}
	copier.Copy(res, exOrder)
	return res, nil
}

func (l *ExchangeOrderLogic) CancelOrder(req *order.OrderReq) (*order.CancelOrderRes, error) {
	orderId := req.OrderId
	err := l.orderDomain.UpdateOrderStatusCancel(l.ctx, orderId, int(req.UpdateStatus))
	if err != nil {
		return nil, err
	}
	return &order.CancelOrderRes{OrderId: orderId}, nil
}
~~~

~~~go

func (d *ExchangeOrderDomain) AddOrder(ctx context.Context, conn msdb.DbConn, exchangeOrder *model.ExchangeOrder, coin *mclient.ExchangeCoin, wallet *ucclient.MemberWallet, coinWallet *ucclient.MemberWallet) (float64, error) {
	exchangeOrder.Status = model.Trading
	exchangeOrder.TradedAmount = 0
	exchangeOrder.Time = time.Now().UnixMilli()
	exchangeOrder.OrderId = tools.Unique("E")
	var money float64
	if exchangeOrder.Direction == model.BUY {
		var turnover float64 = 0
		if exchangeOrder.Type == model.MarketPrice {
			turnover = exchangeOrder.Amount
		} else {
			turnover = op.MulN(exchangeOrder.Amount, exchangeOrder.Price, 5)
		}
		//费率
		fee := op.MulN(turnover, coin.Fee, 5)
		if wallet.Balance < turnover {
			return 0, errors.New("余额不足")
		}
		if wallet.Balance-turnover < fee {
			return 0, errors.New("手续费不足 需要:" + fmt.Sprintf("%f", fee))
		}
		//需要冻结的钱 turnover+fee
		money = op.AddN(turnover, fee, 5)
	} else {
		fee := op.MulN(exchangeOrder.Amount, coin.Fee, 5)
		if coinWallet.Balance < exchangeOrder.Amount {
			return 0, errors.New("余额不足")
		}
		if wallet.Balance-exchangeOrder.Amount < fee {
			return 0, errors.New("手续费不足 需要:" + fmt.Sprintf("%f", fee))
		}
		money = op.AddN(exchangeOrder.Amount, fee, 5)
	}
	err := d.exchangeOrderRepo.Save(ctx, conn, exchangeOrder)
	if err != nil {
		return 0, err
	}
	return money, nil
}

func (d *ExchangeOrderDomain) FindByOrderId(ctx context.Context, orderId string) (*model.ExchangeOrder, error) {
	exchangeOrder, err := d.exchangeOrderRepo.FindByOrderId(ctx, orderId)
	if err == nil && exchangeOrder == nil {
		return nil, errors.New("订单号不存在")
	}
	return exchangeOrder, err
}

func (d *ExchangeOrderDomain) UpdateOrderStatusCancel(ctx context.Context, orderId string, updateStatus int) error {
	return d.exchangeOrderRepo.UpdateOrderStatusCancel(ctx, orderId, model.Canceled, updateStatus, time.Now().UnixMilli())
}
~~~

~~~go
package enums

type Enum map[int]string

func (e Enum) Code(value string) (int, bool) {
	for k, v := range e {
		if v == value {
			return k, true
		}
	}
	return -1, false
}

func (e Enum) Value(code int) (string, bool) {
	value, ok := e[code]
	return value, ok
}

~~~

~~~go

package repo

import (
	"context"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/model"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
)

type ExchangeOrderRepo interface {
	FindBySymbolPage(
		ctx context.Context,
		symbol string,
		memId int64,
		status int,
		page int,
		pageSize int,
		isDesc bool) (list []*model.ExchangeOrder, total int64, err error)
	FindCount(
		ctx context.Context,
		memberId int64,
		symbol string,
		directionCode int,
		trading int) (int64, error)
	Save(ctx context.Context, conn msdb.DbConn, order *model.ExchangeOrder) error
	FindByOrderId(ctx context.Context, orderId string) (*model.ExchangeOrder, error)
	UpdateOrderStatusCancel(ctx context.Context, orderId string, status int, updateStatus int, cancelTime int64) error
}

~~~

~~~go

func (d *ExchangeOrderDao) UpdateOrderStatusCancel(ctx context.Context, orderId string, status int, updateStatus int, cancelTime int64) error {
	session := d.conn.Session(ctx)
	err := session.Model(&model.ExchangeOrder{}).Where("order_id=? and status=?", orderId, updateStatus).Update("status=?", status).Update("canceled_time=?", cancelTime).Error
	return err
}

func (d *ExchangeOrderDao) FindByOrderId(ctx context.Context, orderId string) (o *model.ExchangeOrder, err error) {
	session := d.conn.Session(ctx)
	err = session.Model(&model.ExchangeOrder{}).Where("order_id=?", orderId).Take(&o).Error
	if err != nil {
		return nil, nil
	}
	return
}

func (d *ExchangeOrderDao) Save(ctx context.Context, conn msdb.DbConn, order *model.ExchangeOrder) error {
	d.conn = conn.(*gorms.GormConn)
	tx := d.conn.Tx(ctx)
	err := tx.Save(&order).Error
	return err
}
~~~

~~~go
package domain

import (
	"encoding/json"
	"github.com/LCY2013/blockchain/exchange/ff-coin/exchange/internal/database"
	"github.com/zeromicro/go-zero/core/logx"
)

type KafkaDomain struct {
	kafkaClient *database.KafkaClient
}

func (d *KafkaDomain) Send(
	topic string,
	userId int64,
	orderId string,
	money float64,
	symbol string,
	direction int,
	baseSymbol string,
	coinSymbol string) bool {
	m := make(map[string]any)
	m["userId"] = userId
	m["orderId"] = orderId
	m["money"] = money
	m["symbol"] = symbol
	m["direction"] = direction
	m["baseSymbol"] = baseSymbol
	m["coinSymbol"] = coinSymbol
	marshal, _ := json.Marshal(m)
	data := database.KafkaData{
		Topic: topic,
		Key:   []byte(orderId),
		Data:  marshal,
	}
	logx.Info(string(marshal))
	return d.kafkaClient.SendSync(data)
}

func NewKafkaDomain(kafkaClient *database.KafkaClient) *KafkaDomain {
	return &KafkaDomain{
		kafkaClient: kafkaClient,
	}
}

~~~

### 4.3 接收消息扣减金额

~~~yaml
UCenterRpc:
  Etcd:
    Hosts:
      - 127.0.0.1:2379
    Key: ucenter.rpc
  NonBlock: true
~~~

~~~go
package consumer

import (
	"context"
	"encoding/json"
	"errors"
	"github.com/zeromicro/go-zero/core/logx"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"ffcoin/grpc-common/exchange/eclient"
	"ffcoin/grpc-common/exchange/order"
	"ffcoin/ucenter/internal/database"
	"ffcoin/ucenter/internal/domain"
	"time"
)

// m["userId"] = userId
//
//	m["orderId"] = orderId
//	m["money"] = money
//	m["symbol"] = symbol
//	m["direction"] = direction
//	m["baseSymbol"] = baseSymbol
//	m["coinSymbol"] = coinSymbol
type OrderAdd struct {
	UserId     int64   `json:"userId"`
	OrderId    string  `json:"orderId"`
	Money      float64 `json:"money"`
	Symbol     string  `json:"symbol"`
	Direction  int     `json:"direction"`
	BaseSymbol string  `json:"baseSymbol"`
	CoinSymbol string  `json:"coinSymbol"`
}

func ExchangeOrderAddConsumer(client *database.KafkaClient, db *msdb.MsDB, orderRpc eclient.Order) {
	for {
		kafkaData, _ := client.Read()
		if kafkaData == nil {
			continue
		}
		var addData OrderAdd
		err := json.Unmarshal(kafkaData.Data, &addData)

		if err != nil {
			//不是这个消息 消息类型错误
			logx.Error(err)
			continue
		}
		logx.Info("读取到订单添加消息：", string(kafkaData.Data))
		orderId := string(kafkaData.Key)
		if addData.OrderId != orderId {
			logx.Error(errors.New("不合法的消息，订单号不匹配"))
			continue
		}
		//查询订单信息 如果是正在交易中 继续 否则return
		ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
		exchangeOrder, err := orderRpc.FindByOrderId(ctx, &order.OrderReq{
			OrderId: orderId,
		})
		if err != nil {
			cancelOrder(client, orderRpc, ctx, orderId, exchangeOrder, kafkaData)
			continue
		}

		walletDomain := domain.NewMemberWalletDomain(db)
		if addData.Direction == 0 {
			//buy baseSymbol
			err := walletDomain.Freeze(ctx, addData.UserId, addData.Money, addData.BaseSymbol)
			if err != nil {
				//重新消费
				cancelOrder(client, orderRpc, ctx, orderId, exchangeOrder, kafkaData)
				continue
			}
		} else if addData.Direction == 1 {
			//sell coinSymbol
			err := walletDomain.Freeze(ctx, addData.UserId, addData.Money, addData.CoinSymbol)
			if err != nil {
				//重新消费
				cancelOrder(client, orderRpc, ctx, orderId, exchangeOrder, kafkaData)
				continue
			}
		}
	}

}

func cancelOrder(client *database.KafkaClient, orderRpc eclient.Order, ctx context.Context, orderId string, exchangeOrder *eclient.ExchangeOrderOrigin, kafkaData *database.KafkaData) {
	var status int32 = 0
	if exchangeOrder != nil {
		status = exchangeOrder.Status
	}
	_, err := orderRpc.CancelOrder(ctx, &order.OrderReq{
		OrderId:      orderId,
		UpdateStatus: status,
	})
	if err != nil {
		client.RPut(kafkaData)
	}
}

~~~

~~~go
client := database.NewKafkaClient(c.Kafka)
	client = client.StartRead(c.ExchangeOrderAddTopic)
	order := eclient.NewOrder(zrpc.MustNewClient(c.ExchangeRpc))
	go consumer.ExchangeOrderAddConsumer(client, db, order)
~~~

~~~go

func (d *MemberWalletDomain) Freeze(ctx context.Context, userId int64, money float64, symbol string) error {
	mw, err := d.memberWalletRepo.FindByIdAndCoinName(ctx, userId, symbol)
	if err != nil {
		return err
	}
	if mw.Balance < money {
		return errors.New("余额不足")
	}
	err = d.memberWalletRepo.UpdateFreeze(ctx, userId, money, symbol)
	return err
}
~~~

~~~go
type MemberWalletRepo interface {
	Save(ctx context.Context, mw *model.MemberWallet) error
	FindByIdAndCoinName(ctx context.Context, memId int64, coinName string) (mw *model.MemberWallet, err error)
	UpdateFreeze(ctx context.Context, memId int64, money float64, symbol string) error
}
~~~

~~~go
func (m *MemberWalletDao) UpdateFreeze(ctx context.Context, memId int64, money float64, symbol string) error {
	session := m.conn.Session(ctx)
	query := "update member_wallet set balance=balance-?,frozen_balance=frozen_balance+? where member_id=? and coin_name=? and balance > ?"
	exec := session.Exec(query, money, money, memId, symbol, money)
	err := exec.Error
	if err != nil {
		return err
	}
	affected := exec.RowsAffected
	if affected <= 0 {
		return errors.New("no update row")
	}
	return nil
}
~~~



## 5. 订单潜在问题解决

### 5.1 订单状态

上述有个问题，如果扣减失败取消订单的过程中，订单被执行如何解决。

这里我们应该将订单创建状态初始为Init，并不将其显示出来，也就是说Init状态的订单无法被操作。

~~~go
func (d *KafkaDomain) Send(topic string, userId int64, orderId string, money float64, symbol string, direction int, baseSymbol string, coinSymbol string, status int) bool {
	m := make(map[string]any)
	m["userId"] = userId
	m["orderId"] = orderId
	m["money"] = money
	m["symbol"] = symbol
	m["direction"] = direction
	m["baseSymbol"] = baseSymbol
	m["coinSymbol"] = coinSymbol
	m["status"] = status
	marshal, _ := json.Marshal(m)
	data := database.KafkaData{
		Topic: topic,
		Key:   []byte(orderId),
		Data:  marshal,
	}
	logx.Info(string(marshal))
	return d.kafkaClient.SendSync(data)
}
~~~

~~~go

func (d *ExchangeOrderDomain) AddOrder(ctx context.Context, conn msdb.DbConn, exchangeOrder *model.ExchangeOrder, coin *mclient.ExchangeCoin, wallet *ucclient.MemberWallet, coinWallet *ucclient.MemberWallet) (float64, error) {
	exchangeOrder.Status = model.Init
	exchangeOrder.TradedAmount = 0
	exchangeOrder.Time = time.Now().UnixMilli()
	exchangeOrder.OrderId = tools.Unique("E")
	var money float64
	if exchangeOrder.Direction == model.BUY {
		var turnover float64 = 0
		if exchangeOrder.Type == model.MarketPrice {
			turnover = exchangeOrder.Amount
		} else {
			turnover = op.MulN(exchangeOrder.Amount, exchangeOrder.Price, 5)
		}
		//费率
		fee := op.MulN(turnover, coin.Fee, 5)
		if wallet.Balance < turnover {
			return 0, errors.New("余额不足")
		}
		if wallet.Balance-turnover < fee {
			return 0, errors.New("手续费不足 需要:" + fmt.Sprintf("%f", fee))
		}
		//需要冻结的钱 turnover+fee
		money = op.AddN(turnover, fee, 5)
	} else {
		fee := op.MulN(exchangeOrder.Amount, coin.Fee, 5)
		if coinWallet.Balance < exchangeOrder.Amount {
			return 0, errors.New("余额不足")
		}
		if wallet.Balance-exchangeOrder.Amount < fee {
			return 0, errors.New("手续费不足 需要:" + fmt.Sprintf("%f", fee))
		}
		money = op.AddN(exchangeOrder.Amount, fee, 5)
	}
	err := d.exchangeOrderRepo.Save(ctx, conn, exchangeOrder)
	if err != nil {
		return 0, err
	}
	return money, nil
}
~~~

~~~go
err = l.transaction.Action(func(conn msdb.DbConn) error {
		money, err := l.orderDomain.AddOrder(l.ctx, conn, exchangeOrder, exchangeCoin, baseWallet, exCoinWallet)
		if err != nil {
			return errors.New("订单提交失败")
		}
		//通过kafka发送订单消息，进行钱包货币扣除 同步发送 要保证发送成功
		ok := l.kafkaDomain.Send(
			"add-exchange-order",
			req.UserId,
			exchangeOrder.OrderId,
			money,
			req.Symbol,
			exchangeOrder.Direction,
			baseSymbol,
			coinSymbol,
			model.Init)
		if !ok {
			return errors.New("消息队列出现故障，未能扣款")
		}
		logx.Info("发送成功，订单id:", exchangeOrder.OrderId)
		return nil
	})
~~~

~~~go
func NewKafkaDomain(kafkaClient *database.KafkaClient, orderDomain *ExchangeOrderDomain) *KafkaDomain {
	k := &KafkaDomain{
		kafkaClient: kafkaClient,
		orderDomain: orderDomain,
	}
	go k.WaitAddOrderResult("exchange_order_init_complete")
	return k
}

~~~



~~~go

func (d *KafkaDomain) WaitAddOrderResult(topic string) {
	client := d.kafkaClient.StartRead(topic)
	for {
		data, _ := client.Read()
		logx.Info("收到订单增加结果:" + string(data.Data))
		var result AddOrderResult
		json.Unmarshal(data.Data, &result)
		err := d.orderDomain.UpdateOrderStatusTrading(result.OrderId)
		if err != nil {
			logx.Error(err)
			client.RPut(data)
			continue
		}
		order, err := d.orderDomain.exchangeOrderRepo.FindByOrderId(context.Background(), result.OrderId)
		if err != nil {
			logx.Error(err)
			continue
		}
		//订单初始化完成 发送消息到kafka 等待撮合交易引擎进行交易撮合
		for {
			bytes, _ := json.Marshal(order)
			orderData := database.KafkaData{
				Topic: "exchange_order_trading",
				Key:   []byte(order.OrderId),
				Data:  bytes,
			}
			sendSync := client.SendSync(orderData)
			if !sendSync {
				time.Sleep(250 * time.Millisecond)
				continue
			}
			logx.Info("订单创建成功，发送创建成功消息:", order.OrderId)
			break
		}
	}
}
~~~

~~~go

func (w *KafkaClient) Close() {
	if w.w != nil {
		w.w.Close()
		w.mutex.Lock()
		defer w.mutex.Unlock()
		if !w.closed {
            if w.data != nil{
                close(w.data)
            }
			
			w.closed = true
		}
	}
	if w.r != nil {
		w.r.Close()
	}
}
~~~

~~~go
package consumer

import (
	"context"
	"encoding/json"
	"errors"
	"github.com/zeromicro/go-zero/core/logx"
	"github.com/zeromicro/go-zero/core/stores/redis"
	"github.com/LCY2013/blockchain/exchange/ff-coin/ffcoin-common/msdb"
	"ffcoin/grpc-common/exchange/eclient"
	"ffcoin/grpc-common/exchange/order"
	"ffcoin/ucenter/internal/database"
	"ffcoin/ucenter/internal/domain"
	"time"
)

// m["userId"] = userId
//
//	m["orderId"] = orderId
//	m["money"] = money
//	m["symbol"] = symbol
//	m["direction"] = direction
//	m["baseSymbol"] = baseSymbol
//	m["coinSymbol"] = coinSymbol
type OrderAdd struct {
	UserId     int64   `json:"userId"`
	OrderId    string  `json:"orderId"`
	Money      float64 `json:"money"`
	Symbol     string  `json:"symbol"`
	Direction  int     `json:"direction"`
	BaseSymbol string  `json:"baseSymbol"`
	CoinSymbol string  `json:"coinSymbol"`
	Status     int     `json:"status"`
}

var InitStatus = 4

func ExchangeOrderAddConsumer(client *database.KafkaClient, db *msdb.MsDB, orderRpc eclient.Order, node *redis.Redis) {
	for {
		kafkaData, _ := client.Read()
		if kafkaData == nil {
			continue
		}
		var addData OrderAdd
		err := json.Unmarshal(kafkaData.Data, &addData)

		if err != nil {
			//不是这个消息 消息类型错误
			logx.Error(err)
			continue
		}
		logx.Info("读取到订单添加消息：", string(kafkaData.Data))
		orderId := string(kafkaData.Key)
		if addData.OrderId != orderId {
			logx.Error(errors.New("不合法的消息，订单号不匹配"))
			continue
		}
		if addData.Status != 4 {
			logx.Error(errors.New("不合法的消息，订单状态不是Init, 请注意此订单是否已经被非法修改:" + orderId))
			continue
		}

		ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
		//查询订单信息 如果是正在交易中 继续 否则return
		exchangeOrder, err := orderRpc.FindByOrderId(ctx, &order.OrderReq{
			OrderId: orderId,
		})
		if err != nil {
			cancelOrder(client, orderRpc, ctx, orderId, InitStatus, kafkaData)
			continue
		}
		if exchangeOrder.GetStatus() != int32(InitStatus) {
			logx.Error(errors.New("订单状态不是Init, 请注意此订单是否已经被非法修改:" + orderId))
			continue
		}
		//transaction := tran.NewTransaction(db)
		//transaction.Action(func(conn msdb.DbConn) error {
		//
		//})
		walletDomain := domain.NewMemberWalletDomain(db)
		if addData.Direction == 0 {
			//buy baseSymbol
			err := walletDomain.Freeze(ctx, addData.UserId, addData.Money, addData.BaseSymbol)
			if err != nil {
				//重新消费
				cancelOrder(client, orderRpc, ctx, orderId, int(exchangeOrder.GetStatus()), kafkaData)
				continue
			}
		} else if addData.Direction == 1 {
			//sell coinSymbol
			err := walletDomain.Freeze(ctx, addData.UserId, addData.Money, addData.CoinSymbol)
			if err != nil {
				//重新消费
				cancelOrder(client, orderRpc, ctx, orderId, int(exchangeOrder.GetStatus()), kafkaData)
				continue
			}
		}
		//都完成后 通知订单进行状态变更 需要保证一定发送成功
		for {
			m := make(map[string]any)
			m["userId"] = addData.UserId
			m["orderId"] = orderId
			marshal, _ := json.Marshal(m)
			data := database.KafkaData{
				Topic: "exchange_order_init_complete",
				Key:   []byte(orderId),
				Data:  marshal,
			}
			sendSync := client.SendSync(data)
			if !sendSync {
				time.Sleep(250 * time.Millisecond)
				continue
			}
			break
		}
	}

}

func cancelOrder(client *database.KafkaClient, orderRpc eclient.Order, ctx context.Context, orderId string, originStatus int, kafkaData *database.KafkaData) error {
	_, err := orderRpc.CancelOrder(ctx, &order.OrderReq{
		OrderId:      orderId,
		UpdateStatus: int32(originStatus),
	})
	if err != nil {
		client.RPut(kafkaData)
		return err
	}
	return nil
}

~~~

### 5.2 分布式锁

在进行钱包操作的时候，我们可以将其进行加锁，以防集群环境下的操作。

~~~go
lock := redis.NewRedisLock(node, "exchange_order::"+fmt.Sprintf("%d::%s", addData.UserId, orderId))
		//查询订单信息 如果是正在交易中 继续 否则return
		acquireCtx, err := lock.AcquireCtx(ctx)
		if err != nil {
			logx.Error(err)
			logx.Info("已经有别的进程处理此消息")
			continue
		}
if acquireCtx {}
~~~

### 5.3 加上事务

~~~go
transaction := tran.NewTransaction(db)
			err = transaction.Action(func(conn msdb.DbConn) error {
				walletDomain := domain.NewMemberWalletDomain(db)
				if addData.Direction == 0 {
					//buy baseSymbol
					err := walletDomain.Freeze(ctx, conn, addData.UserId, addData.Money, addData.BaseSymbol)
					if err != nil {
						//重新消费
						err := cancelOrder(client, orderRpc, ctx, orderId, int(exchangeOrder.GetStatus()), kafkaData)
						if err != nil {
							return err
						}

					}
				} else if addData.Direction == 1 {
					//sell coinSymbol
					err := walletDomain.Freeze(ctx, conn, addData.UserId, addData.Money, addData.CoinSymbol)
					if err != nil {
						//重新消费
						err := cancelOrder(client, orderRpc, ctx, orderId, int(exchangeOrder.GetStatus()), kafkaData)
						if err != nil {
							return err
						}
					}
				}
				return nil
			})
~~~

